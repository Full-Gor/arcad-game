// laser_beam.js - Laser balayé (beam)

// Variables pour les power-ups Néon
let neonPowerUps = {
    speed: 1,
    multishot: 1,
    damage: 1
};

// Fonction pour activer un power-up Néon
export function activateNeonPowerUp(type, value) {
    switch(type) {
        case 'speed':
            neonPowerUps.speed = value;
            break;
        case 'multishot':
            neonPowerUps.multishot = value;
            break;
        case 'damage':
            neonPowerUps.damage = value;
            break;
    }
}

// Fonction pour obtenir les valeurs des power-ups
export function getNeonPowerUps() {
    return { ...neonPowerUps };
}

export function createLaserBeam(enemy) {
  return {
    type: 'laser_beam_mod',
    x: enemy.x + enemy.width / 2,
    y: enemy.y + enemy.height,
    width: 3 * neonPowerUps.damage,
    sweepAngle: -Math.PI / 4,
    sweepSpeed: 0.02 * neonPowerUps.speed,
    sweepRange: Math.PI / 2,
    color: '#ff0000',
    glowColor: '#ff6666',
    coreColor: '#ffffff', // Added for inner core
    duration: 3000,
    startTime: Date.now(),
    opacity: 1,
    pulsePhase: 0 // For pulsing effect
  };
}

export function updateLaserBeam(beam) {
  const elapsed = Date.now() - beam.startTime;
  beam.sweepAngle += beam.sweepSpeed;
  if (Math.abs(beam.sweepAngle) > beam.sweepRange / 2) {
    beam.sweepSpeed *= -1;
  }
  beam.pulsePhase = Math.sin(elapsed / 100) * 0.2 + 1; // Pulsing width/opacity
  if (elapsed > beam.duration) return true;
  if (elapsed < 200) beam.opacity = elapsed / 200; else if (elapsed > beam.duration - 200) beam.opacity = (beam.duration - elapsed) / 200;
  return false;
}

export function drawLaserBeam(ctx, beam) {
  ctx.save();
  ctx.globalAlpha = beam.opacity;
  ctx.translate(beam.x, beam.y);
  ctx.rotate(beam.sweepAngle);
  const laserLength = ctx.canvas.height;

  // Draw glow layers for enhanced effect
  const glowWidths = [beam.width * 3 * beam.pulsePhase, beam.width * 2 * beam.pulsePhase, beam.width * beam.pulsePhase];
  const glowColors = ['rgba(255, 102, 102, 0.2)', 'rgba(255, 102, 102, 0.4)', 'rgba(255, 102, 102, 0.6)'];

  for (let i = 0; i < glowWidths.length; i++) {
    const gradient = ctx.createLinearGradient(0, 0, 0, laserLength);
    gradient.addColorStop(0, glowColors[i]);
    gradient.addColorStop(0.5, 'transparent');
    gradient.addColorStop(1, 'transparent');
    ctx.fillStyle = gradient;
    ctx.fillRect(-glowWidths[i]/2, 0, glowWidths[i], laserLength);
  }

  // Draw core beam
  const coreGradient = ctx.createLinearGradient(0, 0, 0, laserLength);
  coreGradient.addColorStop(0, beam.coreColor);
  coreGradient.addColorStop(0.3, beam.color);
  coreGradient.addColorStop(0.7, beam.glowColor);
  coreGradient.addColorStop(1, 'transparent');
  ctx.fillStyle = coreGradient;
  ctx.fillRect(-beam.width/2, 0, beam.width, laserLength);

  // Add particle sparks for embellishment
  ctx.globalAlpha = beam.opacity * 0.8;
  for (let i = 0; i < 5; i++) {
    const sparkY = Math.random() * laserLength;
    const sparkOffset = (Math.random() - 0.5) * beam.width * 1.5;
    const sparkSize = Math.random() * 2 + 1;
    ctx.beginPath();
    ctx.arc(sparkOffset, sparkY, sparkSize, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
  }

  ctx.restore();
}