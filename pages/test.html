<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Animation de Tir de Vaisseau Spatial Embellie avec WebGL</title>
    <style>
        body { background-color: black; margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 1px solid white; }
    </style>
</head>
<body>
    <canvas id="glcanvas" width="800" height="600"></canvas>
    <script>
        // Variables pour les power-ups Néon
        let neonPowerUps = {
            speed: 1,
            multishot: 1,
            damage: 1
        };

        // Fonction pour activer un power-up Néon
        function activateNeonPowerUp(type, value) {
            switch(type) {
                case 'speed':
                    neonPowerUps.speed = value;
                    break;
                case 'multishot':
                    neonPowerUps.multishot = value;
                    break;
                case 'damage':
                    neonPowerUps.damage = value;
                    break;
            }
        }

        // Fonction pour obtenir les valeurs des power-ups
        function getNeonPowerUps() {
            return { ...neonPowerUps };
        }

        function createLaserBeam(enemy) {
          return {
            type: 'laser_beam_mod',
            x: enemy.x + enemy.width / 2,
            y: enemy.y + enemy.height,
            width: 3 * neonPowerUps.damage,
            sweepAngle: -Math.PI / 4,
            sweepSpeed: 0.02 * neonPowerUps.speed,
            sweepRange: Math.PI / 2,
            color: '#ff0000',
            glowColor: '#ff6666',
            duration: 3000,
            startTime: Date.now(),
            opacity: 1
          };
        }

        function updateLaserBeam(beam) {
          const elapsed = Date.now() - beam.startTime;
          beam.sweepAngle += beam.sweepSpeed;
          if (Math.abs(beam.sweepAngle) > beam.sweepRange / 2) {
            beam.sweepSpeed *= -1;
          }
          if (elapsed > beam.duration) return true;
          if (elapsed < 200) beam.opacity = elapsed / 200; else if (elapsed > beam.duration - 200) beam.opacity = (beam.duration - elapsed) / 200;
          return false;
        }

        // Fonctions mat4
        function mat4Identity() {
            return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
        }

        function mat4Translate(tx, ty, tz = 0) {
            return [1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1];
        }

        function mat4RotateZ(angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return [c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1];
        }

        function mat4Scale(sx, sy, sz = 1) {
            return [sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1];
        }

        function mat4Multiply(a, b) {
            const out = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    out[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        out[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return out;
        }

        function createOrtho2D(width, height) {
            return [
                2 / width, 0, 0, 0,
                0, -2 / height, 0, 0,
                0, 0, 1, 0,
                -1, 1, 0, 1
            ];
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        // Shaders
        const vsSource = `
            attribute vec2 aPosition;
            uniform mat4 uMVP;
            uniform float uWidth;
            varying float vY;
            varying float vDist;
            void main() {
                gl_Position = uMVP * vec4(aPosition, 0.0, 1.0);
                vY = aPosition.y;
                vDist = aPosition.x * uWidth;
            }
        `;

        const fsSource = `
            precision mediump float;
            uniform vec3 uColor;
            uniform vec3 uGlowColor;
            uniform float uOpacity;
            uniform float uSigma;
            uniform float uTime;
            varying float vY;
            varying float vDist;

            vec2 hash(vec2 p) {
                p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
                return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
            }

            float noise(in vec2 p) {
                const float K1 = 0.366025404;
                const float K2 = 0.211324865;
                vec2 i = floor(p + (p.x + p.y) * K1);
                vec2 a = p - i + (i.x + i.y) * K2;
                vec2 o = step(a.yx, a.xy);
                vec2 b = a - o + K2;
                vec2 c = a - 1.0 + 2.0 * K2;
                vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
                h = h * h * h * h;
                vec3 n = h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));
                return dot(n, vec3(70.0));
            }

            void main() {
                float dist = abs(vDist);
                float intensity = exp(-0.5 * pow(dist / uSigma, 2.0));
                intensity *= (0.7 + 0.3 * noise(vec2(0.0, vY * 8.0 + uTime * 0.5)));
                vec3 col = mix(uColor, uGlowColor, smoothstep(0.0, 0.5, vY));
                col = mix(col, vec3(0.0), smoothstep(0.5, 1.0, vY));
                float alpha = (1.0 - smoothstep(0.5, 1.0, vY)) * intensity * uOpacity;
                gl_FragColor = vec4(col * intensity, alpha);
            }
        `;

        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL non supporté');
        }

        const vs = compileShader(gl, vsSource, gl.VERTEX_SHADER);
        const fs = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        const positionLoc = gl.getAttribLocation(program, 'aPosition');
        const uMvpLoc = gl.getUniformLocation(program, 'uMVP');
        const uColorLoc = gl.getUniformLocation(program, 'uColor');
        const uGlowColorLoc = gl.getUniformLocation(program, 'uGlowColor');
        const uOpacityLoc = gl.getUniformLocation(program, 'uOpacity');
        const uSigmaLoc = gl.getUniformLocation(program, 'uSigma');
        const uTimeLoc = gl.getUniformLocation(program, 'uTime');
        const uWidthLoc = gl.getUniformLocation(program, 'uWidth');

        const projection = createOrtho2D(canvas.width, canvas.height);

        let vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        const positions = new Float32Array([-0.5, 0, 0.5, 0, -0.5, 1, 0.5, 1]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        let indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        const indices = new Uint16Array([0, 1, 2, 1, 3, 2]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Activation de power-ups pour démonstration
        activateNeonPowerUp('damage', 3);
        activateNeonPowerUp('speed', 2);

        const enemy = { x: canvas.width / 2 - 25, y: 50, width: 50, height: 20 };
        let beam = createLaserBeam(enemy);

        function drawLaserBeam(gl, beam) {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            const glowFactor = 5;
            const total_width = beam.width * glowFactor;
            const sigma = beam.width * 0.5;
            const laserLength = canvas.height * 2; // Pour couvrir l'écran même pivoté

            const translate = mat4Translate(beam.x, beam.y);
            const rotate = mat4RotateZ(beam.sweepAngle);
            const scale = mat4Scale(total_width, laserLength);
            const model = mat4Multiply(translate, mat4Multiply(rotate, scale));
            const mvp = mat4Multiply(projection, model);

            gl.useProgram(program);
            gl.uniformMatrix4fv(uMvpLoc, false, mvp);
            gl.uniform3fv(uColorLoc, hexToRgb(beam.color));
            gl.uniform3fv(uGlowColorLoc, hexToRgb(beam.glowColor));
            gl.uniform1f(uOpacityLoc, beam.opacity);
            gl.uniform1f(uSigmaLoc, sigma);
            gl.uniform1f(uTimeLoc, (Date.now() - beam.startTime) / 1000);
            gl.uniform1f(uWidthLoc, total_width);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionLoc);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }

        function animate() {
            if (updateLaserBeam(beam)) {
                // Redémarrer pour boucle
                beam = createLaserBeam(enemy);
            }
            drawLaserBeam(gl, beam);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>