<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Guerre-galactique</title>
    <style>
        /* Styles de base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            touch-action: none; /* Désactive les gestes tactiles par défaut */
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        /* Canvas du jeu */
        #gameCanvas {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: block;
            touch-action: none;
        }

        /* Interface utilisateur */
        .stats {
            position: absolute;
            top: min(20px, 5vh);
            left: min(20px, 5vw);
            font-size: clamp(14px, 4vw, 20px);
            z-index: 10;
        }

        #coinsCount {
            position: absolute;
            top: min(20px, 5vh);
            right: min(20px, 5vw);
            font-size: clamp(14px, 4vw, 20px);
            z-index: 10;
        }

        /* Conteneur vidéo */
        #videoContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #powerUpVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Changé à contain pour meilleure visibilité sur mobile */
        }

        /* Écrans de fin de jeu */
        #gameOverContainer {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.9);
            color: red;
            font-family: Arial, sans-serif;
        }

        #continueCounter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(50px, 20vw, 100px);
            text-align: center;
        }

        #gameOverMessage {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            color: red;
            padding: min(50px, 10vw);
            font-size: clamp(40px, 15vw, 100px);
            border: 5px solid red;
            z-index: 2001;
            text-align: center;
            width: min(90%, 500px);
        }

        .player-stats {
            position: fixed;
            right: min(20px, 5vw);
            top: min(60px, 15vh);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: clamp(12px, 3vw, 16px);
            z-index: 10;
            max-width: 90vw;
        }

        .player-stats-item {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .player1-stats {
            background: rgba(4, 251, 172, 0.2);
        }

        .player2-stats {
            background: rgba(255, 127, 80, 0.2);
        }

        .player3-stats {
            background: rgba(255, 255, 80, 0.2);
        }

        /* Style pour l'indicateur de vie du boss */
        #bossHealthBar {
            position: absolute;
            top: min(50px, 10vh);
            left: 50%;
            transform: translateX(-50%);
            width: min(300px, 80vw);
            height: min(20px, 4vh);
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid red;
            display: none;
            z-index: 10;
        }

        #bossHealthFill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff6600);
            width: 100%;
            transition: width 0.3s;
        }

        @keyframes rotateBackground {
            from { background-position: 0 0; }
            to { background-position: 100% 0; }
        }

        .scrolling-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('/img/back1.png') repeat-x;
            background-size: auto 100%;
            z-index: -1;
            animation: rotateBackground 60s linear infinite;
        }

       /* Animation de bouclier */
@keyframes shieldPulse {
    0% {
        transform: scale(1) rotate(0deg);
        opacity: 0.6;
        box-shadow: 0 0 15px currentColor, inset 0 0 10px currentColor;
    }
    50% {
        transform: scale(1.1) rotate(180deg);
        opacity: 0.8;
        box-shadow: 0 0 25px currentColor, inset 0 0 20px currentColor;
    }
    100% {
        transform: scale(1) rotate(360deg);
        opacity: 0.6;
        box-shadow: 0 0 15px currentColor, inset 0 0 10px currentColor;
    }
}

.shield-effect {
    animation: shieldPulse 10s infinite linear;
    border: 2px solid currentColor;
    border-radius: 50%;
    position: absolute;
    pointer-events: none;
    z-index: 900;
    background: radial-gradient(circle at center, transparent 60%, currentColor 100%);
}

.shield-effect::before, .shield-effect::after {
    content: '';
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    border: 1px solid currentColor;
    border-radius: 50%;
    animation: shieldPulse 3s infinite linear reverse;
    opacity: 0.5;
}

.shield-effect::after {
    top: -5px;
    left: -5px;
    right: -5px;
    bottom: -5px;
    border: 1px dashed currentColor;
    animation-duration: 5s;
    animation-direction: normal;
}

/* Nouveau style pour les particules de bouclier individuelles */
@keyframes particleBlink {
    0%, 100% { opacity: 0.2; }
    50% { opacity: 1; }
}

.shield-particle {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    animation: particleBlink 1s infinite alternate;
}
       

        .touch-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 999;
            display: none;
        }
       
        .player-mode {
            font-size: clamp(14px, 4vw, 20px);
        }

        /* Adaptation pour orientation paysage vs portrait */
        @media (orientation: portrait) {
            .player-stats {
                top: min(120px, 20vh);
                max-width: 80vw;
            }
        }
        #gameCanvas {
    cursor: none;
}
#stageTitle {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    color: #ff0000;
    text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
    text-align: center;
    opacity: 0;
    transition: opacity 2s;
    z-index: 1000;
    pointer-events: none;
    font-weight: bold;
    display: none;
}
@keyframes scrollBackgroundVertical {
    from { background-position: 0 100%; }  /* Commencer du bas */
    to { background-position: 0 0%; }      /* Défiler vers le haut */
}
    </style>
</head>
<body>
    <!-- Interface utilisateur -->
    <span id="coinsCount">0</span>
   <div class="stats">
    Vies: <span id="livesCount">3</span><br>
    Ennemis tués: <span id="enemiesKilledCount">0</span><br>
    Points rouges: <span id="redPointsCount">0</span>/100
</div>

    <!-- Fond d'écran défilant -->
    <div id="scrollingBackground" class="scrolling-background" style="display: none;"></div>
   
    <!-- Barre de vie du boss -->
    <div id="bossHealthBar">
        <div id="bossHealthFill"></div>
    </div>

    <div class="player-mode" id="playerModeIndicator" style="position: absolute; top: min(20px, 5vh); left: 50%; transform: translateX(-50%); color: #04fbac; z-index: 10;">Mode 1 joueur</div>
    <div id="playerStats" class="player-stats" style="display: none;">
        <div id="player1Stats" class="player-stats-item player1-stats">
    Player 1: <span id="p1Lives">3</span> vies |
            Points: <span id="p1Points">0</span> |
            Kills: <span id="p1Kills">0</span>
        </div>
        <div id="player2Stats" class="player-stats-item player2-stats">
            Player 2: <span id="p2Lives">3</span> vies |
            Points: <span id="p2Points">0</span> |
            Kills: <span id="p2Kills">0</span>
        </div>
        <div id="player3Stats" class="player-stats-item player3-stats">
            Player 3: <span id="p3Lives">3</span> vies |
            Points: <span id="p3Points">0</span> |
            Kills: <span id="p3Kills">0</span>
        </div>
    </div>
    <div id="stageTitle">STAGE 2: PLANÈTE DÉSOLÉE</div>

    <!-- Indicateur de toucher -->
    <div id="touchIndicator" class="touch-indicator"></div>

    <!-- Canvas du jeu -->
    <canvas id="gameCanvas"></canvas>

    <!-- Conteneur vidéo pour les power-ups -->
    <div id="videoContainer">
        <video id="powerUpVideo" src="video/tirePlasma.mp4" playsinline></video>
    </div>

    <!-- Conteneurs pour le game over -->
    <div id="gameOverContainer">
        <div id="continueCounter"></div>
    </div>
    <div id="gameOverMessage">GAME OVER</div>

    <script>
        // Configuration initiale
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
       

       

        // Récupération des paramètres de difficulté
        const enemySpeedMultiplier = parseFloat(localStorage.getItem('enemySpeed')) || 1;
        const enemyBulletSpeedMultiplier = parseFloat(localStorage.getItem('enemyBulletSpeed')) || 3;
        const powerUpFrequency = parseInt(localStorage.getItem('powerUpFrequency')) || 5;
        const livesFrequency = parseInt(localStorage.getItem('livesFrequency')) || 5;

        // Object Pool pour les points rouges - OPTIMISATION ANTI-LAG
        class RedPointPool {
            constructor(initialSize = 500) {
                this.pool = [];
                this.activePoints = new Set();
                this.maxActivePoints = 400;
                
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(this.createRedPoint());
                }
                console.log(`🔴 RedPointPool initialisé avec ${initialSize} objets`);
            }
            
            createRedPoint() {
                return {
                    x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0,
                    color: 'red', isExplosion: false, isActive: false
                };
            }
            
            getPoint() {
                if (this.activePoints.size >= this.maxActivePoints) {
                    return null; // Refuser l'allocation pour éviter les lags
                }
                
                let point = this.pool.pop();
                if (!point) point = this.createRedPoint();
                
                point.isActive = true;
                this.activePoints.add(point);
                return point;
            }
            
            releasePoint(point) {
                if (!point.isActive) return;
                point.isActive = false;
                this.activePoints.delete(point);
                point.x = point.y = point.vx = point.vy = point.life = 0;
                point.isExplosion = false;
                this.pool.push(point);
            }
        }
        
        const redPointPool = new RedPointPool(500);

        // Variables globales
        
        let gameIsRunning = true;
        let lastFrameTime = 0;
        let deltaTime = 0;
        let fpsCounter = 0;
        let fpsTimer = 0;
        const fpsLimit = 60;
        const frameDuration = 1000 / fpsLimit;
        let redPointsTotal = 0; // Compteur global pour les points rouges collectés
        
        // FORMATION ASSISTANTS - Variables globales
        let isFormationActive = false;
        let formationPositions = [];
        
        // Calculer les positions de formation triangle
        function calculateFormationPositions() {
            const centerX = starship.x + starship.width / 2;
            const centerY = starship.y - 80; // Au-dessus du joueur
            const spacing = 60;
            
            // Formation triangle pour 6 assistants :
            //     1
            //   2   3
            //  4  5  6
            return [
                { x: centerX - 25, y: centerY - spacing * 2 },      // 1: Sommet
                { x: centerX - spacing - 25, y: centerY - spacing }, // 2: Gauche milieu  
                { x: centerX + spacing - 25, y: centerY - spacing }, // 3: Droite milieu
                { x: centerX - spacing * 1.5 - 25, y: centerY },     // 4: Gauche bas
                { x: centerX - 25, y: centerY },                     // 5: Centre bas
                { x: centerX + spacing * 1.5 - 25, y: centerY }      // 6: Droite bas
            ];
        }
        // Variables pour le stage 2
let isStage2 = false;
let stage2EnemiesKilled = 0;


// Variables pour le stage 3
let isStage3 = false;
let stage3Phase = 0;
let stage3EnemyTypes = [10, 11, 12, 13, 14, 15, 16, 17]; // Types d'ennemis pour le stage 3
let stage3CurrentEnemyType = 0;
let stage3EnemiesSpawned = 0;
let stage3EnemiesKilled = 0;

// CORRECTION 3: Améliorer la fonction startStage3 pour assurer la transition correcte
function startStage3() {
    console.log("Début du Stage 3");
    
    // Changer le fond d'écran et le configurer pour un défilement vertical
    const scrollingBg = document.getElementById("scrollingBackground");
    scrollingBg.style.backgroundImage = "url('/img/back2.png')";
    scrollingBg.style.display = "block";
    scrollingBg.style.filter = "brightness(0.9) contrast(1.1)";
    
    // Configuration horizontale avec défilement vertical
    scrollingBg.style.backgroundSize = "100% auto"; // Étirer sur la largeur
    scrollingBg.style.backgroundPosition = "center bottom"; // Commencer par le bas
    scrollingBg.style.animation = "scrollBackgroundVertical 60s linear infinite";
    
    // Réinitialiser les variables du stage 3
    isStage3 = true;
    isStage2 = false; // S'assurer que le stage 2 est désactivé
    stage3Phase = 0;
    stage3CurrentEnemyType = 0;
    stage3EnemiesSpawned = 0;
    
    // Vider les ennemis actuels pour faire place aux nouveaux
    enemies = [];
    
    // Afficher le titre de stage 3
    const stageTitle = document.getElementById("stageTitle");
    stageTitle.textContent = "STAGE 3: ZONE DE GUERRE";
    stageTitle.style.display = "block";
    stageTitle.style.opacity = "0"; // S'assurer qu'il est initialement invisible
    
    // Animation de fade-in
    setTimeout(() => {
        stageTitle.style.opacity = "1";
        
        // Animation de fade-out après 3 secondes
        setTimeout(() => {
            stageTitle.style.opacity = "0";
            
            // Masquer l'élément après la transition
            setTimeout(() => {
                stageTitle.style.display = "none";
            }, 2000);
        }, 3000);
    }, 100);
    
    // Augmenter la difficulté
    enemySpeedMultiplier *= 1.5;
    enemyBulletSpeedMultiplier *= 1.5;
}


function generateStage3Enemies() {
    if (!isStage3 || gameManager.isPaused) return;
    
    // Vérifier si nous devons passer au prochain type d'ennemi
    if (stage3EnemiesSpawned >= 5) {
        stage3CurrentEnemyType++;
        stage3EnemiesSpawned = 0;
        
        // Revenir au premier type si on a parcouru tous les types
        if (stage3CurrentEnemyType >= stage3EnemyTypes.length) {
            stage3CurrentEnemyType = 0;
        }
    }
    
    // Générer des ennemis du type actuel (tous les mêmes pour chaque vague)
    if (stage3EnemiesSpawned < 5 && enemies.length < 30) {
        const enemyType = stage3EnemyTypes[stage3CurrentEnemyType] - 10; // Ajuster l'index pour les nouvelles images
        
        // Générer 5 ennemis à la fois
        for (let i = 0; i < 5; i++) {
            enemies.push({
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height / 3),
                width: 60,
                height: 60,
                vx: (Math.random() * 2 - 1) * 3, // Vitesse un peu plus rapide
                vy: Math.random() * 2,
                type: enemyType
            });
        }
        
        stage3EnemiesSpawned += 5;
    }
}


function defeatBoss2() {
    console.log("Création du stage 3 après défaite du boss 2");
   
    // Jouer un son
    playSound(soundEffects.bossDeath);
    
    // Créer un effet d'explosion
    for (let i = 0; i < 150; i++) {
        redPoints.push({
            x: boss.x + Math.random() * boss.width,
            y: boss.y + Math.random() * boss.height,
            isExplosion: true,
            vx: (Math.random() * 2 - 1) * 4,
            vy: (Math.random() * 2 - 1) * 4,
            life: 30 + Math.floor(Math.random() * 30),
            color: ["red", "orange", "yellow", "white"][Math.floor(Math.random() * 4)]
        });
    }
   
    // Désactiver le boss
    bossActive = false;
    boss = null;
   
    // Cacher la barre de vie
    document.getElementById("bossHealthBar").style.display = "none";
   
    // Réinitialiser l'opacité
    ctx.globalAlpha = 1.0;
   
    // Donner un bonus de points
    enemiesKilled += 10;
    document.getElementById("enemiesKilledCount").innerText = enemiesKilled;
   
    // Bonus pour tous les joueurs actifs
    if (isMultiplayer) {
        const p1Points = parseInt(document.getElementById("p1Points").textContent) + 100;
        document.getElementById("p1Points").textContent = p1Points;
       
        if (starship2 && starship2.isActive) {
            const p2Points = parseInt(document.getElementById("p2Points").textContent) + 100;
            document.getElementById("p2Points").textContent = p2Points;
        }
       
        if (isTriplePlayer && starship3 && starship3.isActive) {
            const p3Points = parseInt(document.getElementById("p3Points").textContent) + 100;
            document.getElementById("p3Points").textContent = p3Points;
        }
    }
   
    // Démarrer le stage 3
    startStage3();
   
    // Ajouter quelques power-ups
    bonusManager.addPowerUp(2);
    bonusManager.addLife();
}


function defeatBoss3() {
    console.log("Défaite du boss 3");
    
    // Jouer un son
    playSound(soundEffects.bossDeath);
    
    // Explosion massive
    for (let i = 0; i < 300; i++) {
        redPoints.push({
            x: boss.x + Math.random() * boss.width,
            y: boss.y + Math.random() * boss.height,
            isExplosion: true,
            vx: (Math.random() * 2 - 1) * 5,
            vy: (Math.random() * 2 - 1) * 5,
            life: 40 + Math.floor(Math.random() * 40),
            color: ["red", "orange", "yellow", "white", "blue"][Math.floor(Math.random() * 5)]
        });
    }
    
    // Désactiver le boss
    bossActive = false;
    boss = null;
    
    // Cacher la barre de vie
    document.getElementById("bossHealthBar").style.display = "none";
    
    // Bonus de points
    enemiesKilled += 20;
    document.getElementById("enemiesKilledCount").innerText = enemiesKilled;
    
    // Bonus pour tous les joueurs actifs
    if (isMultiplayer) {
        const p1Points = parseInt(document.getElementById("p1Points").textContent) + 300;
        document.getElementById("p1Points").textContent = p1Points;
        
        if (starship2 && starship2.isActive) {
            const p2Points = parseInt(document.getElementById("p2Points").textContent) + 300;
            document.getElementById("p2Points").textContent = p2Points;
        }
        
        if (isTriplePlayer && starship3 && starship3.isActive) {
            const p3Points = parseInt(document.getElementById("p3Points").textContent) + 300;
            document.getElementById("p3Points").textContent = p3Points;
        }
    }
    
    // Donner beaucoup de bonus
    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            bonusManager.addPowerUp(Math.floor(Math.random() * 3));
            bonusManager.addLife();
        }, i * 500);
    }
    
    // Afficher un message de victoire
    const stageTitle = document.getElementById("stageTitle");
    stageTitle.textContent = "VICTOIRE TOTALE!";
    stageTitle.style.color = "gold";
    stageTitle.style.fontSize = "64px";
    stageTitle.style.display = "block";
    stageTitle.style.opacity = "0";
    
    // Animation de fade-in
    setTimeout(() => {
        stageTitle.style.opacity = "1";
        
        // Animation de fade-out après 5 secondes
        setTimeout(() => {
            stageTitle.style.opacity = "0";
            
            // Masquer l'élément après la transition
            setTimeout(() => {
                stageTitle.style.display = "none";
                stageTitle.style.color = "#ff0000"; // Réinitialiser la couleur
                stageTitle.style.fontSize = "48px"; // Réinitialiser la taille
            }, 2000);
        }, 5000);
    }, 100);
}
// Modifier la fonction de génération d'ennemis existante
// CORRECTION 7: Améliorer la fonction generateEnemies pour intégrer le stage 3
function generateEnemies() {
    if (gameManager.isPaused) return;

    if (isStage3) {
        generateStage3Enemies();
        return;
    }

    if (enemies.length > 30) {
        return;
    }

    const count = Math.min(7, 30 - enemies.length);

    for (let i = 0; i < count; i++) {
        enemies.push({
            x: Math.random() * (canvas.width - 100) + 50,
            y: Math.random() * (canvas.height / 3),
            width: 60,
            height: 60,
            vx: (Math.random() * 2 - 1) * 2 * enemySpeedMultiplier,
            vy: Math.random() * 1.5 * enemySpeedMultiplier,
            type: Math.floor(Math.random() * 6)
        });
    }
}
const boss2Img = new Image();
boss2Img.src = "/img/boss2.jpg";
const boss3Img = new Image();
boss3Img.src = "/img/boss3.png";

        // Détection des appareils mobiles
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// Variables tactiles
let touchActive = false;
let lastTouchX = 0;
let lastTouchY = 0;
let touchShootInterval = null;
const touchIndicator = document.getElementById("touchIndicator");

        // Variables de jeu
// Remplacez les variables existantes pour l'éclair par celles-ci
let thunderActive = false;
let thunderCount = 0; // Compteur d'éclairs actifs (0, 1, 2, 3)
let thunderStartTime = 0;
let thunderDirections = [
    { angle: 90 },     // Horizontalement vers la droite (90 degrés)
    { angle: 135 },    // Diagonale bas-droite (135 degrés)
    { angle: 45 }      // Diagonale haut-droite (45 degrés)
];
        let shooting = false;
        let enemies = [];
        let enemyBullets = [];
        let stars = [];
let starImg = new Image();
starImg.src = "/img/star.png"; // Créez ou obtenez une image d'étoile

// Variables pour le tir spécial
let specialShotAvailable = false;
let specialBullets = [];
let specialShotReady = false;
let enemiesDestroyedWithoutHit = 0;

// Variables pour les vaisseaux assistants
let assistantShips = []; // Tableau qui contiendra tous les vaisseaux assistants
let redPointsForNextAssistant = 50; // Points rouges nécessaires pour le prochain assistant
let nextAssistantShipIndex = 1; // Index pour alterner entre les différentes images
        let enemiesKilled = 0;
        let playerLives = 3;
        let simultaneousKills = 0;
        let killTimer = null;
        let redPoints = [];
        let coins = 0;
        let killsWithoutDeath = 0;
        let lastKillTime = Date.now();
        let lastEnemyCount = 0;
        let powerUpTimeoutId = null;

        // Boss configuration
        let bossActive = false;
        let boss = null;
        const bossImg = new Image();
        bossImg.src = "/img/boss.jpg";
        let bossHealth = 500; // Augmenté à 500
        let bossRotation = 0;
        let bossShootTimer = 0;
        let bossHitEffect = false;
        let bossHitEffectTimer = 0;
        let backgroundActive = false;
        // Variables pour le mini-boss
        let miniBossActive = false;
        let miniBosses = []; // Tableau pour stocker les mini-boss actifs
const miniBossImg = new Image();
miniBossImg.src = "/img/miniBoss.jpg";
let miniBossHealth = 50;
let miniBossShootTimer = 0;


        // Configuration multijoueur
        const urlParams = new URLSearchParams(window.location.search);
        const playersCount = urlParams.get('players') || '1';
        const isMultiplayer = playersCount !== '1';
        const isTriplePlayer = playersCount === '3';

        // Mise à jour de l'indicateur de mode
        document.getElementById('playerModeIndicator').textContent =
            isTriplePlayer ? 'Mode 3 joueurs' :
            (isMultiplayer ? 'Mode 2 joueurs' : 'Mode 1 joueur');

        // Configuration des vaisseaux
        const starship = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            width: 50,
            height: 50,
            bullets: [],
            powerUpLevel: 0,
            player: 1,
            powerUpTimeoutId: null,
            lives: 3,
            isActive: true,
            stunned: false,
            stunnedTimeout: null,
            redPointsCollected: 0,
            shield: false,
            shieldTimeout: null
        };

        const starship2 = isMultiplayer ? {
            x: canvas.width / 2 + 100,
            y: canvas.height - 50,
            width: 50,
            height: 50,
            bullets: [],
            powerUpLevel: 0,
            player: 2,
            powerUpTimeoutId: null,
            lives: 3,
            isActive: true,
            stunned: false,
            stunnedTimeout: null,
            redPointsCollected: 0,
            shield: false,
            shieldTimeout: null
        } : null;

        const starship3 = isTriplePlayer ? {
            x: canvas.width / 2 - 100,
            y: canvas.height - 50,
            width: 50,
            height: 50,
            bullets: [],
            powerUpLevel: 0,
            player: 3,
            powerUpTimeoutId: null,
            lives: 3,
            isActive: true,
            stunned: false,
            stunnedTimeout: null,
            redPointsCollected: 0,
            shield: false,
            shieldTimeout: null
        } : null;

        // Variables de contrôle
        let keyUp = false, keyDown = false, keyLeft = false, keyRight = false, keySpace = false;
        let keyW = false, keyS = false, keyA = false, keyD = false, keyE = false;
        let shooting2 = false;
        let shooting3 = false;
        let gamepadConnected = false;
        let gamepadIndex = null;
        let shipRotation = 0;
        const maxRotation = 20;
        const rotationSpeed = 0.5;
        let lastShipX = canvas.width/2;

        // Chargement des sons
const soundEffects = {
    shoot: new Audio("/audio/shoot.mp3"),
    hit: new Audio("/audio/hit.mp3"),
    coin: new Audio("/audio/coin.mp3"),
    king: new Audio("/audio/king.mp3"),
    perfect: new Audio("/audio/perfect.mp3"),
    doubleKill: new Audio("/audio/doubleKill.mp3"),
    tripleKill: new Audio("/audio/tripleKill.mp3"),
    humiliation: new Audio("/audio/humiliation.mp3"),
    brutal: new Audio("/audio/brutal.mp3"),
    super: new Audio("/audio/super.mp3"),
    master: new Audio("/audio/master.mp3"),
    awesome: new Audio("/audio/awesome.mp3"),
    bossAppear: new Audio("/audio/king.mp3"),
    bossHit: new Audio("/audio/hit.mp3"),
    bossDeath: new Audio("/audio/awesome.mp3"),
    continue: new Audio("/audio/continue.mp3"),
    gameOver: new Audio("/audio/gameOver.mp3")
};

// Configuration des volumes
const volumes = {
    shoot: 0.3,
    hit: 1.0,
    coin: 0.3,
    king: 0.6,
    perfect: 0.4,
    doubleKill: 0.7,
    tripleKill: 0.5,
    humiliation: 1.0,
    brutal: 1.0,
    super: 1.0,
    master: 1.0,
    awesome: 1.0,
    bossAppear: 1.0,
    bossHit: 0.5,
    bossDeath: 1.0,
    continue: 1.0,
    gameOver: 1.0
};

Object.keys(soundEffects).forEach(key => {
    soundEffects[key].volume = volumes[key] || 1.0;
});
// Configuration améliorée des particules de bouclier
const shieldParticles = {
  particleCount: 25,  // Plus de particules
  particles: [],
  orbitalParticles: [], // Nouvelles particules en suspension
  colors: ["#04fbac", "#00ffff", "#0088ff", "#80ffff"],
  minSize: 2,
  maxSize: 5,
  minSpeed: 0.02,
  maxSpeed: 0.05,
  suspensionCount: 15 // Nombre de particules en suspension
};

// Modifiez la fonction createAssistantShip pour initialiser correctement les propriétés
function createAssistantShip() {
    // Limiter à 6 assistants maximum
    if (assistantShips.length >= 6) return;
    // Déterminer l'image à utiliser pour ce vaisseau assistant
    const imgIndex = nextAssistantShipIndex;
    nextAssistantShipIndex = (nextAssistantShipIndex % 6) + 1; // Alterne entre 1-6
    
    const assistantShipImgSrc = `/img/starship${imgIndex}.jpg`;
    const assistantShipImg = new Image();
    assistantShipImg.src = assistantShipImgSrc;
    
    // Calculer une position X aléatoire pour le nouveau vaisseau
    const randomPosition = Math.random() * (canvas.width - 150) + 50;
    
    // Créer le nouvel objet vaisseau assistant
    const newAssistantShip = {
        x: randomPosition,
        y: canvas.height + 50, // Commence en dehors de l'écran (en bas)
        targetY: canvas.height - 150 - (assistantShips.length * 20), // Position Y cible initiale (étagée)
        width: 50,
        height: 50,
        lastShootTime: 0,
        shootInterval: 500 + (assistantShips.length * 100), // Intervalle de tir (plus lent pour chaque nouveau)
        originalShootInterval: 500 + (assistantShips.length * 100),
        bullets: [],
        speed: 3,
        isEntering: true,
        moveDirection: Math.random() < 0.5 ? 1 : -1, // Direction de mouvement aléatoire
        moveTimer: Math.random() * Math.PI * 2, // Décalage de phase pour éviter mouvement synchronisé
        health: 3,
        isHit: false,
        powerUpLevel: 0,
        imageIndex: imgIndex, // Stocker l'index de l'image
        image: assistantShipImg, // Stocker l'image directement
        
        // Propriétés du bouclier
        shield: {
            active: false,
            radius: 40,
            timer: 0,
            duration: 3000
        },
        
        // CORRECTION: Compteur individuel pour chaque assistant
        redPointsCollected: 0
    };
    
    // Ajouter le nouveau vaisseau au tableau
    assistantShips.push(newAssistantShip);
    
    // Définir le seuil pour le prochain assistant
    redPointsForNextAssistant += 50;
    
    // Effet d'annonce
    const assistantMessage = document.createElement("div");
    assistantMessage.style.position = "absolute";
    assistantMessage.style.left = "50%";
    assistantMessage.style.top = "40%";
    assistantMessage.style.transform = "translate(-50%, -50%)";
    assistantMessage.style.color = "#FFFFFF";
    assistantMessage.style.fontSize = "30px";
    assistantMessage.style.fontWeight = "bold";
    assistantMessage.style.padding = "20px";
    assistantMessage.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    assistantMessage.style.borderRadius = "10px";
    assistantMessage.style.textAlign = "center";
    assistantMessage.style.zIndex = "100";
    assistantMessage.style.textShadow = "0 0 10px #04fbac";
    assistantMessage.textContent = `VAISSEAU ASSISTANT ${assistantShips.length} ACTIVÉ!`;
    document.body.appendChild(assistantMessage);
    
    // Jouer un son
    playSound(soundEffects.awesome);
    
    // Retirer le message après 3 secondes
    setTimeout(() => {
        document.body.removeChild(assistantMessage);
    }, 3000);
}
// Fonction principale qui gère tous les vaisseaux assistants
function updateAndDrawAssistantShips() {
    // Vérifier si on doit créer un nouvel assistant
    if (redPointsTotal >= redPointsForNextAssistant) {
        createAssistantShip();
    }
    
    // FORMATION ASSISTANTS - Mettre à jour les positions si en formation
    if (isFormationActive && assistantShips.length > 0) {
        formationPositions = calculateFormationPositions();
    }
    
    // Mettre à jour et dessiner chaque vaisseau assistant
    for (let i = assistantShips.length - 1; i >= 0; i--) {
        updateAndDrawSingleAssistantShip(assistantShips[i], i);
    }
}

// Fonction pour définir la couleur de chaque vaisseau assistant selon son image
function getAssistantColor(imageIndex, asRGB = false) {
    const colors = {
        1: asRGB ? "rgb(200, 50, 50)" : "#c83232", // Rouge pour starship1
        2: asRGB ? "rgb(50, 50, 200)" : "#3232c8", // Bleu pour starship2
        3: asRGB ? "rgb(50, 200, 50)" : "#32c832", // Vert pour starship3
        4: asRGB ? "rgb(200, 200, 50)" : "#c8c832", // Jaune pour starship4
        5: asRGB ? "rgb(200, 50, 200)" : "#c832c8", // Magenta pour starship5
        6: asRGB ? "rgb(50, 200, 200)" : "#32c8c8", // Cyan pour starship6
        7: asRGB ? "rgb(4, 251, 172)" : "#04fbac"   // Couleur par défaut
    };
    
    return colors[imageIndex] || colors[7]; // Retourne la couleur ou une couleur par défaut
}

// Fonction pour définir la couleur des balles de chaque vaisseau assistant
function getAssistantBulletColor(imageIndex) {
    const colors = {
        1: "#ff8080", // Rouge clair pour starship1
        2: "#8080ff", // Bleu clair pour starship2
        3: "#80ff80", // Vert clair pour starship3
        4: "#ffff80", // Jaune clair pour starship4
        5: "#ff80ff", // Magenta clair pour starship5
        6: "#80ffff", // Cyan clair pour starship6
        7: "#04fbac"  // Couleur par défaut
    };
    
    return colors[imageIndex] || colors[7]; // Retourne la couleur ou une couleur par défaut
}

// Fonction helper pour afficher un texte flottant
function showFloatingText(text, x, y, color) {
    // Créer un élément texte
    const textElement = document.createElement("div");
    textElement.style.position = "absolute";
    textElement.style.left = x + "px";
    textElement.style.top = y + "px";
    textElement.style.color = color;
    textElement.style.fontWeight = "bold";
    textElement.style.fontSize = "16px";
    textElement.style.textShadow = "0 0 5px #000";
    textElement.style.zIndex = "999";
    textElement.style.pointerEvents = "none";
    textElement.textContent = text;
    document.body.appendChild(textElement);
    
    // Animation
    let opacity = 1.0;
    let posY = y;
    
    const animateText = () => {
        opacity -= 0.02;
        posY -= 1;
        
        textElement.style.opacity = opacity;
        textElement.style.top = posY + "px";
        
        if (opacity > 0) {
            requestAnimationFrame(animateText);
        } else {
            document.body.removeChild(textElement);
        }
    };
    
    requestAnimationFrame(animateText);
}

function updateAndDrawSingleAssistantShip(assistantShip, index) {
    if (!assistantShip || gameManager.isPaused) return;
    
    // Phase de mise à jour - gestion du mouvement et du comportement du vaisseau assistant
    
    // Si l'animation d'entrée est active, déplacer le vaisseau du bas vers la position cible
   if (assistantShip.isEntering) {
    assistantShip.y -= assistantShip.speed;
    
    // Limiter targetY pour éviter le chevauchement
    const minY = 100; // Position minimale en Y
    const maxY = canvas.height - 200; // Position maximale en Y
    assistantShip.targetY = Math.max(minY, Math.min(maxY, assistantShip.targetY));
        
        // Si la position cible est atteinte, terminer la phase d'entrée
        if (assistantShip.y <= assistantShip.targetY) {
            assistantShip.y = assistantShip.targetY;
            assistantShip.isEntering = false;
        }
    } else {
        // FORMATION ASSISTANTS - Logique de mouvement
        if (isFormationActive && formationPositions[index]) {
            // Mode formation : se diriger vers la position assignée
            const targetPos = formationPositions[index];
            const dx = targetPos.x - assistantShip.x;
            const dy = targetPos.y - assistantShip.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                const speed = 3;
                assistantShip.x += (dx / distance) * speed;
                assistantShip.y += (dy / distance) * speed;
            }
        } else {
            // Mode libre - mouvement d'origine
            assistantShip.moveTimer += 0.01;
            
            // Déplacer la position basée sur une onde sinusoïdale pour un mouvement fluide
            assistantShip.x += Math.sin(assistantShip.moveTimer) * 2 * assistantShip.moveDirection;
            
            // S'assurer que le vaisseau reste dans les limites de l'écran
            if (assistantShip.x < 0) {
                assistantShip.x = 0;
                assistantShip.moveDirection *= -1;
            } else if (assistantShip.x + assistantShip.width > canvas.width) {
                assistantShip.x = canvas.width - assistantShip.width;
                assistantShip.moveDirection *= -1;
            }
            
            // Changer de direction aléatoirement de temps en temps
            if (Math.random() < 0.005) {
                assistantShip.moveDirection *= -1;
            }
        }
        
        // Tirer automatiquement des balles
        const currentTime = Date.now();
        if (currentTime - assistantShip.lastShootTime > assistantShip.shootInterval) {
            // Le nombre de balles dépend du niveau de powerUp
            const bulletConfigs = [
                [{ offset: 0 }], // Niveau 0: une balle au centre
                [{ offset: -8 }, { offset: 8 }], // Niveau 1: deux balles
                [{ offset: -16 }, { offset: 0 }, { offset: 16 }] // Niveau 2+: trois balles
            ];
            
            // Choisir la configuration en fonction du niveau de powerUp
            const config = bulletConfigs[Math.min(assistantShip.powerUpLevel, 2)];
            
            // Créer les balles selon la configuration
            for (let bulletCfg of config) {
                const bulletSize = 4;
                const bullet = {
                    x: assistantShip.x + assistantShip.width / 2 - bulletSize / 2 + bulletCfg.offset,
                    y: assistantShip.y,
                    width: bulletSize,
                    height: bulletSize,
                    speed: 12,
                    // Couleur différente selon l'index du vaisseau
                    color: getAssistantBulletColor(assistantShip.imageIndex),
                    player: 1, // Associé au joueur 1 pour la détection de collision
                    isAssistantBullet: true
                };
                
                starship.bullets.push(bullet);
            }
            
            assistantShip.lastShootTime = currentTime;
        }
        
        // CORRECTION: Timer bouclier assistants (5 secondes = 5000ms)
        if (assistantShip.shield.active) {
            assistantShip.shield.timer += 16; // ~60fps
            if (assistantShip.shield.timer >= 5000) { // Force 5 secondes
                assistantShip.shield.active = false;
                assistantShip.shield.timer = 0;
            }
        }
    }
    
    // Vérifier les collisions avec les balles ennemies
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        if (!bullet) continue;
        
        // Vérifier la collision
        if (checkCollision(assistantShip, bullet)) {
            // Supprimer la balle ennemie
            enemyBullets.splice(i, 1);
            
            // Ne prendre des dégâts que si le bouclier n'est pas actif
            if (!assistantShip.shield.active) {
                // Effet visuel de touche
                assistantShip.isHit = true;
                
                // Réduire la santé
                assistantShip.health--;
                
                // Jouer un son
                playSound(soundEffects.hit);
                
                // Effets de particules
                for (let j = 0; j < 10; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    redPoints.push({
                        x: assistantShip.x + assistantShip.width/2 + Math.cos(angle) * 10,
                        y: assistantShip.y + assistantShip.height/2 + Math.sin(angle) * 10,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 10 + Math.floor(Math.random() * 5),
                        isExplosion: true,
                        color: getAssistantColor(assistantShip.imageIndex)
                    });
                }
                
                // Vérifier si le vaisseau est détruit
                if (assistantShip.health <= 0) {
                    // Créer une explosion finale
                    for (let j = 0; j < 30; j++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 1 + Math.random() * 3;
                        redPoints.push({
                            x: assistantShip.x + Math.random() * assistantShip.width,
                            y: assistantShip.y + Math.random() * assistantShip.height,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 20 + Math.floor(Math.random() * 10),
                            isExplosion: true,
                            color: ["yellow", "orange", "white"][Math.floor(Math.random() * 3)]
                        });
                    }
                    
                    // Supprimer ce vaisseau assistant du tableau
                    assistantShips.splice(index, 1);
                    
                    // Jouer un son de destruction
                    playSound(soundEffects.bossDeath);
                    
                    return; // Sortir de la fonction car le vaisseau est détruit
                }
            } else {
                // Si le bouclier est actif, créer un effet visuel de "rebond"
                const angle = Math.random() * Math.PI * 2;
                for (let j = 0; j < 5; j++) {
                    redPoints.push({
                        x: bullet.x,
                        y: bullet.y,
                        vx: Math.cos(angle + j * Math.PI/4) * 2,
                        vy: Math.sin(angle + j * Math.PI/4) * 2,
                        life: 10,
                        isExplosion: true,
                        color: "cyan"
                    });
                }
            }
        }
    }
    
    // Vérifier les collisions avec les power-ups
    for (let i = bonusManager.powerUps.length - 1; i >= 0; i--) {
        const powerUp = bonusManager.powerUps[i];
        if (!powerUp) continue;
        
        if (checkCollision(assistantShip, powerUp)) {
            // Analyser le type de power-up et appliquer l'effet approprié
            if (powerUp.type === 0) { // Type 0 - Éclair
                // Activer le bouclier
                assistantShip.shield.active = true;
                assistantShip.shield.timer = Date.now();
                assistantShip.shield.duration = 5000; // 5 secondes de bouclier
                
                // Message
                showFloatingText("BOUCLIER!", assistantShip.x, assistantShip.y - 20, "#00ffff");
            } else if (powerUp.type === 1) { // Type 1 - Amélioration d'armes
                // Augmenter le niveau de puissance des tirs
                assistantShip.powerUpLevel = Math.min(2, assistantShip.powerUpLevel + 1);
                
                // Augmenter la cadence de tir
                assistantShip.shootInterval = Math.max(200, assistantShip.originalShootInterval - (assistantShip.powerUpLevel * 100));
                
                // Message
                showFloatingText("ARMES +1", assistantShip.x, assistantShip.y - 20, "#ff00ff");
            } else if (powerUp.type === 2) { // Type 2 - Power-up spécial
                // Effet spécial: déclenchement du bouclier + amélioration d'armes
                assistantShip.shield.active = true;
                assistantShip.shield.timer = Date.now();
                assistantShip.shield.duration = 8000; // 8 secondes de bouclier
                
                assistantShip.powerUpLevel = 2; // Niveau maximal
                assistantShip.shootInterval = 200; // Tir rapide
                
                // Message
                showFloatingText("POWER-UP COMPLET!", assistantShip.x, assistantShip.y - 20, "#ffffff");
            }
            
            // Jouer un son
            playSound(soundEffects.coin);
            
            // Supprimer le power-up
            bonusManager.powerUps.splice(i, 1);
            
            // Effet visuel
            for (let j = 0; j < 15; j++) {
                const angle = Math.random() * Math.PI * 2;
                redPoints.push({
                    x: assistantShip.x + assistantShip.width/2,
                    y: assistantShip.y + assistantShip.height/2,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    life: 15,
                    isExplosion: true,
                    color: getAssistantColor(assistantShip.imageIndex)
                });
            }
        }
    }
    
    // Vérifier les collisions avec les vies supplémentaires
    for (let i = bonusManager.lives.length - 1; i >= 0; i--) {
        const life = bonusManager.lives[i];
        if (!life) continue;
        
        if (checkCollision(assistantShip, life)) {
            // Augmenter la santé du vaisseau assistant
            assistantShip.health = Math.min(5, assistantShip.health + 1);
            
            // Jouer un son
            playSound(soundEffects.perfect);
            
            // Message
            showFloatingText("VIE +1", assistantShip.x, assistantShip.y - 20, "#ff0000");
            
            // Supprimer la vie
            bonusManager.lives.splice(i, 1);
            
            // Effet visuel
            for (let j = 0; j < 15; j++) {
                const angle = Math.random() * Math.PI * 2;
                redPoints.push({
                    x: assistantShip.x + assistantShip.width/2,
                    y: assistantShip.y + assistantShip.height/2,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    life: 15,
                    isExplosion: true,
                    color: "red"
                });
            }
        }
    }
    
    // Phase de dessin - rendu du vaisseau assistant et de ses effets
    
    // Dessiner le vaisseau assistant
    ctx.save();
    
    // Appliquer des effets visuels si le vaisseau a été touché
    if (assistantShip.isHit) {
        ctx.globalAlpha = 0.7;
        assistantShip.isHit = false;
    }
    
    // Dessiner l'image du vaisseau
    if (assistantShip.image && assistantShip.image.complete) {
        ctx.drawImage(
            assistantShip.image,
            assistantShip.x,
            assistantShip.y,
            assistantShip.width,
            assistantShip.height
        );
    } else {
        // Solution de secours si l'image n'est pas chargée
        ctx.fillStyle = getAssistantColor(assistantShip.imageIndex);
        ctx.fillRect(
            assistantShip.x,
            assistantShip.y,
            assistantShip.width,
            assistantShip.height
        );
    }
    
    // Dessiner le bouclier s'il est actif
    if (assistantShip.shield.active) {
        ctx.beginPath();
        ctx.arc(
            assistantShip.x + assistantShip.width / 2,
            assistantShip.y + assistantShip.height / 2,
            assistantShip.shield.radius,
            0,
            Math.PI * 2
        );
        
        // Créer un dégradé pour le bouclier basé sur la couleur du vaisseau
        const shieldColor = getAssistantColor(assistantShip.imageIndex, true);
        const gradient = ctx.createRadialGradient(
            assistantShip.x + assistantShip.width / 2,
            assistantShip.y + assistantShip.height / 2,
            assistantShip.shield.radius * 0.7,
            assistantShip.x + assistantShip.width / 2,
            assistantShip.y + assistantShip.height / 2,
            assistantShip.shield.radius
        );
        
        gradient.addColorStop(0, shieldColor.replace("rgb", "rgba").replace(")", ", 0.1)"));
        gradient.addColorStop(0.7, shieldColor.replace("rgb", "rgba").replace(")", ", 0.3)"));
        gradient.addColorStop(1, shieldColor.replace("rgb", "rgba").replace(")", ", 0.5)"));
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Ajouter une bordure au bouclier
        ctx.strokeStyle = shieldColor.replace("rgb", "rgba").replace(")", ", 0.8)");
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    // Dessiner l'indicateur de santé
    for (let i = 0; i < assistantShip.health; i++) {
        ctx.fillStyle = getAssistantColor(assistantShip.imageIndex);
        ctx.fillRect(
            assistantShip.x + (i * 12),
            assistantShip.y - 10,
            10,
            5
        );
    }
    
    // Dessiner l'indicateur de niveau de puissance si > 0
    if (assistantShip.powerUpLevel > 0) {
        ctx.fillStyle = "#ff00ff";
        for (let i = 0; i < assistantShip.powerUpLevel; i++) {
            ctx.fillRect(
                assistantShip.x + (i * 12),
                assistantShip.y - 20,
                10,
                5
            );
        }
    }
    
    ctx.restore();
}
function activateThunder(ship) {
    // Si c'est déjà actif, on ajoute juste un éclair de plus
    if (thunderActive) {
        thunderCount = Math.min(thunderCount + 1, 3); // Maximum 3 éclairs
    } else {
        thunderActive = true;
        thunderCount = 1;
        thunderStartTime = Date.now();
    }
    
    // Jouer un son pour l'éclair
    playSound(soundEffects.king);
}

function updateAndDrawThunder() {
    if (!thunderActive) return;
    
    const currentTime = Date.now();
    const elapsedTime = currentTime - thunderStartTime;
    
    // Vérifier si la durée de 7 secondes est écoulée
    if (elapsedTime > 7000) {
        thunderActive = false;
        thunderCount = 0;
        return;
    }
    
    // Animer la séquence des images (alternance entre les 3 images)
    const thunderFrame = Math.floor(elapsedTime / 100) % 3;
    
    // Pour tous les vaisseaux actifs
    [starship, starship2, starship3].filter(ship => ship && ship.isActive).forEach(ship => {
        // Position de départ (centre du vaisseau)
        const startX = ship.x + ship.width / 2;
        const startY = ship.y;
        
        // Dessiner chaque éclair actif
        for (let i = 0; i < thunderCount; i++) {
            const thunderDirection = thunderDirections[i];
            ctx.save();
            
            // Convertir l'angle en radians pour la rotation de l'image
            const angleRad = (thunderDirection.angle - 90) * Math.PI / 180;
            
            // Appliquer rotation
            ctx.translate(startX, startY);
            ctx.rotate(angleRad);
            
            // Dessiner l'éclair
            if (thunderImgs[thunderFrame].complete) {
                ctx.drawImage(
                    thunderImgs[thunderFrame],
                    -20, // Centré horizontalement
                    -400, // Étend vers le haut
                    40,   // Largeur
                    400   // Longueur
                );
            }
            
            ctx.restore();
            
            // Calculer impacts pour cet éclair
            if (elapsedTime % 200 < 20) {
                for (let j = 1; j <= 5; j++) {
                    // Calculer position du point d'impact en fonction de l'angle
                    const distance = j * 80;
                    
                    // Utiliser l'angle pour calculer correctement la position
                    // Attention: ici on utilise l'angle sans le décalage de -90 utilisé pour l'affichage
                    const calcAngleRad = thunderDirection.angle * Math.PI / 180;
                    const impactX = startX + Math.cos(calcAngleRad) * distance + (Math.random() * 20 - 10);
                    const impactY = startY + Math.sin(calcAngleRad) * distance + (Math.random() * 20 - 10);
                    
                    // Tracer visuellement les points d'impact (pour débogage)
                    ctx.save();
                    ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
                    ctx.beginPath();
                    ctx.arc(impactX, impactY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Vérifier les collisions avec les ennemis
                    for (let k = 0; k < enemies.length; k++) {
                        const enemy = enemies[k];
                        const dist = Math.sqrt(
                            Math.pow(enemy.x + enemy.width/2 - impactX, 2) + 
                            Math.pow(enemy.y + enemy.height/2 - impactY, 2)
                        );
                        
                        // Zone de collision plus grande
                        if (dist < 50) {
                            playSound(soundEffects.hit);
                            
                            // Créer des points rouges
                            for (let l = 0; l < 10; l++) {
                                redPoints.push({
                                    x: enemy.x + Math.random() * enemy.width,
                                    y: enemy.y + Math.random() * enemy.height
                                });
                            }
                            
                            // Supprimer l'ennemi et augmenter le score
                            enemies.splice(k, 1);
                            handleKill(ship.player);
                            break;
                        }
                    }
                }
            }
        }
    });
}
// Créer la fonction d'initialisation des particules
function createShieldParticles(player) {
  // Vider les tableaux de particules existantes
  shieldParticles.particles = shieldParticles.particles.filter(p => p.player !== player.player);
  shieldParticles.orbitalParticles = shieldParticles.orbitalParticles.filter(p => p.player !== player.player);
  
  // Créer les particules orbitales principales
  for (let i = 0; i < shieldParticles.particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const distance = 30 + Math.random() * 10;
    
    shieldParticles.particles.push({
      angle,
      distance,
      size: shieldParticles.minSize + Math.random() * (shieldParticles.maxSize - shieldParticles.minSize),
      speed: shieldParticles.minSpeed + Math.random() * (shieldParticles.maxSpeed - shieldParticles.minSpeed),
      color: shieldParticles.colors[Math.floor(Math.random() * shieldParticles.colors.length)],
      player: player.player,
      opacity: 0.5 + Math.random() * 0.5,
      blinking: Math.random() > 0.7,
      trail: Math.random() > 0.7 // Certaines particules laissent une traînée
    });
  }
  
  // Créer les particules en suspension
  for (let i = 0; i < shieldParticles.suspensionCount; i++) {
    const offsetAngle = Math.random() * Math.PI * 2;
    
    shieldParticles.orbitalParticles.push({
      offsetX: Math.cos(offsetAngle) * (20 + Math.random() * 40),
      offsetY: Math.sin(offsetAngle) * (20 + Math.random() * 40),
      size: 1 + Math.random() * 3,
      color: shieldParticles.colors[Math.floor(Math.random() * shieldParticles.colors.length)],
      player: player.player,
      opacity: 0.4 + Math.random() * 0.6,
      pulseFactor: 0.5 + Math.random() * 0.5,
      pulseSpeed: 0.001 + Math.random() * 0.004,
      moveSpeed: 0.01 + Math.random() * 0.04,
      angle: Math.random() * Math.PI * 2,
      phase: Math.random() * Math.PI * 2,
      trailLength: 1 + Math.floor(Math.random() * 3)
    });
  }
}

// Mettre à jour les particules de bouclier
function updateShieldParticles() {
  if (gameManager.isPaused) return;

  // CORRECTION: Nettoyer les particules orphelines (sans joueur actif)
  shieldParticles.particles = shieldParticles.particles.filter(particle => {
    const player = [starship, starship2, starship3].find(p => p && p.player === particle.player);
    return player && player.isActive && player.shield;
  });
  
  shieldParticles.orbitalParticles = shieldParticles.orbitalParticles.filter(particle => {
    const player = [starship, starship2, starship3].find(p => p && p.player === particle.player);
    return player && player.isActive && player.shield;
  });

  // Pour chaque joueur qui a un bouclier actif
  [starship, starship2, starship3].filter(player => player && player.isActive && player.shield).forEach(player => {
    // Mettre à jour les particules orbitales
    shieldParticles.particles.filter(p => p.player === player.player).forEach(particle => {
      particle.angle += particle.speed;
      if (particle.angle > Math.PI * 2) particle.angle -= Math.PI * 2;
      
      if (particle.blinking) {
        particle.opacity = 0.2 + (Math.sin(Date.now() * 0.01) + 1) * 0.4;
      }
    });
    
    // Mettre à jour les particules en suspension
    shieldParticles.orbitalParticles.filter(p => p.player === player.player).forEach(particle => {
      // Faire fluctuer la particule autour de sa position de base
      particle.angle += particle.moveSpeed;
      if (particle.angle > Math.PI * 2) particle.angle -= Math.PI * 2;
      
      // Faire pulser l'opacité
      particle.opacity = 0.4 + Math.sin(Date.now() * particle.pulseSpeed + particle.phase) * 0.3;
    });
  });
}

// Dessiner les particules de bouclier
function drawShieldParticles() {
  // CORRECTION: Vérifier que le joueur existe ET a un shield actif
  [starship, starship2, starship3].filter(player => player && player.isActive && player.shield).forEach(player => {
    // CORRECTION: Position dynamique du centre du joueur
    const centerX = player.x + player.width / 2;
    const centerY = player.y + player.height / 2;

    // Dessiner d'abord l'aura du bouclier
ctx.save();
const gradient = ctx.createRadialGradient(
  centerX, centerY, player.width / 2,
  centerX, centerY, player.width / 2 + 20
);

// Ajuster la couleur du gradient selon le joueur
const playerColor = player.player === 1 ? '4, 251, 172' : 
                  (player.player === 2 ? '255, 127, 80' : '255, 255, 80');

gradient.addColorStop(0, `rgba(${playerColor}, 0)`);
gradient.addColorStop(0.7, `rgba(${playerColor}, 0.1)`);
gradient.addColorStop(1, `rgba(${playerColor}, 0.2)`);

ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.003) * 0.2;
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(centerX, centerY, player.width / 2 + 20, 0, Math.PI * 2);
ctx.fill();
ctx.restore();
    
   
    
    // Dessiner les particules orbitales principales
    shieldParticles.particles.filter(p => p.player === player.player).forEach(particle => {
      ctx.save();
      
      const x = centerX + Math.cos(particle.angle) * particle.distance;
      const y = centerY + Math.sin(particle.angle) * particle.distance;
      
      // Dessiner d'abord une traînée si la particule en a une
      if (particle.trail) {
        const trailLength = 3;
        for (let i = 1; i <= trailLength; i++) {
          const trailAngle = particle.angle - (particle.speed * i * 2);
          const trailX = centerX + Math.cos(trailAngle) * particle.distance;
          const trailY = centerY + Math.sin(trailAngle) * particle.distance;
          
          ctx.globalAlpha = particle.opacity * (1 - i/trailLength) * 0.5;
          ctx.fillStyle = particle.color;
          ctx.shadowBlur = 8;
          ctx.shadowColor = particle.color;
          
          ctx.beginPath();
          ctx.arc(trailX, trailY, particle.size * (1 - i/trailLength), 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Dessiner la particule principale
      ctx.globalAlpha = particle.opacity;
      ctx.fillStyle = particle.color;
      ctx.shadowBlur = 10;
      ctx.shadowColor = particle.color;
      
      ctx.beginPath();
      ctx.arc(x, y, particle.size, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
    
    // Dessiner les particules en suspension
    shieldParticles.orbitalParticles.filter(p => p.player === player.player).forEach(particle => {
      ctx.save();
      
      // Calculer la position avec un mouvement sinusoïdal
      const waveX = Math.sin(particle.angle) * 5;
      const waveY = Math.cos(particle.angle * 1.3) * 5;
      
      const x = centerX + particle.offsetX + waveX;
      const y = centerY + particle.offsetY + waveY;
      
      // Dessiner la traînée pour les particules en suspension
      for (let i = 1; i <= particle.trailLength; i++) {
        const prevAngle = particle.angle - (particle.moveSpeed * i * 5);
        const prevWaveX = Math.sin(prevAngle) * 5;
        const prevWaveY = Math.cos(prevAngle * 1.3) * 5;
        
        const trailX = centerX + particle.offsetX + prevWaveX;
        const trailY = centerY + particle.offsetY + prevWaveY;
        
        ctx.globalAlpha = particle.opacity * (1 - i/particle.trailLength) * 0.4;
        ctx.fillStyle = particle.color;
        
        ctx.beginPath();
        ctx.arc(trailX, trailY, particle.size * (1 - i/particle.trailLength), 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Dessiner la particule principale avec effet de lueur
      ctx.globalAlpha = particle.opacity;
      ctx.fillStyle = particle.color;
      ctx.shadowBlur = 8;
      ctx.shadowColor = particle.color;
      
      ctx.beginPath();
      ctx.arc(x, y, particle.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Ajouter un halo lumineux pour certaines particules
      if (Math.random() > 0.7) {
        ctx.globalAlpha = particle.opacity * 0.5;
        ctx.beginPath();
        ctx.arc(x, y, particle.size * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    });
  });
}

function activateShield(player, duration = 5000) { // Réduit de 10s à 5s
  if (!player || !player.isActive) return;
  
  player.shield = true;
  
  // Créer un élément pour l'effet de bouclier si nécessaire
  let shieldEffect = document.getElementById("shield-effect-player" + player.player);
  if (!shieldEffect) {
    shieldEffect = document.createElement("div");
    shieldEffect.id = "shield-effect-player" + player.player;
    shieldEffect.className = "shield-effect";
    shieldEffect.style.width = (player.width + 20) + "px";
    shieldEffect.style.height = (player.height + 20) + "px";
    document.body.appendChild(shieldEffect);
  }
  
  // Déterminer la couleur du bouclier selon le joueur
  shieldEffect.style.color = player.player === 1 ? "#04fbac" :
                           player.player === 2 ? "#FF7F50" : "#FFFF50";

  // Initialiser les particules pour ce joueur
  createShieldParticles(player);
  
  // Nettoyer tout timeout existant
  if (player.shieldTimeout) clearTimeout(player.shieldTimeout);
  
  // Désactiver le bouclier après la durée spécifiée
  player.shieldTimeout = setTimeout(() => {
    // CORRECTION: Triple nettoyage pour forcer la disparition
    player.shield = false;
    
    // Supprimer l'élément DOM
    const shieldEffect = document.getElementById("shield-effect-player" + player.player);
    if (shieldEffect) {
      shieldEffect.remove();
    }
    
    // Nettoyage des particules (double passage)
    shieldParticles.particles = shieldParticles.particles.filter(p => p.player !== player.player);
    shieldParticles.orbitalParticles = shieldParticles.orbitalParticles.filter(p => p.player !== player.player);
    
    // Double nettoyage après 100ms pour être sûr
    setTimeout(() => {
      shieldParticles.particles = shieldParticles.particles.filter(p => p.player !== player.player);
      shieldParticles.orbitalParticles = shieldParticles.orbitalParticles.filter(p => p.player !== player.player);
    }, 100);
    
    // Nettoyer le timeout
    player.shieldTimeout = null;
  }, duration);
}

function createStar() {
    // Calculer la position horizontale en fonction du nombre d'étoiles déjà présentes
    const starCount = stars.length;
    const spacing = 60; // Espace entre les étoiles en pixels
    const startX = 20; // Position X de la première étoile
    
    // Position en bas de l'écran, mais avec un X calculé pour l'alignement
    const x = startX + (starCount * spacing);
    const y = canvas.height;
    
    // Créer l'objet étoile
    const star = {
        x: x,
        y: y,
        width: 50, 
        height: 50,
        targetY: 50, // Position cible en haut de l'écran (fixe)
        targetX: x,  // Position horizontale cible (la même que celle de départ)
        speed: 4,    // Vitesse de déplacement
        rotation: 0,
        isMoving: true
    };
    
    // Ajouter au tableau d'étoiles
    stars.push(star);
    
    // Jouer un son pour indiquer l'apparition de l'étoile
    playSound(soundEffects.perfect);
    
    // Réinitialiser le compteur
    enemiesDestroyedWithoutHit = 0;
}

function updateAndDrawStars() {
    if (gameManager.isPaused) return;
    
    for (let i = 0; i < stars.length; i++) {
        const star = stars[i];
        
        // Mettre à jour la position si l'étoile est en mouvement
        if (star.isMoving) {
            star.y -= star.speed;
            
            // Si l'étoile a atteint sa position cible
            if (star.y <= star.targetY) {
                star.y = star.targetY;
                star.isMoving = false;
            }
        }
        
        // Faire tourner l'étoile pour un effet visuel
        star.rotation += 0.1;
        
        // Dessiner l'étoile
        ctx.save();
        ctx.translate(star.x + star.width/2, star.y + star.height/2);
        ctx.rotate(star.rotation);
        
        // Si l'image de l'étoile est chargée, la dessiner
        if (starImg.complete && starImg.naturalWidth > 0) {
            ctx.drawImage(starImg, -star.width/2, -star.height/2, star.width, star.height);
        } else {
            // Sinon, dessiner une étoile simple
            drawSimpleStar(ctx, 0, 0, 5, 25, 10);
        }
        
        ctx.restore();
    }
}

function checkSpecialShotAvailability() {
    // Si 5 étoiles ou plus sont collectées, le tir spécial devient disponible
    if (stars.length >= 5 && !specialShotAvailable) {
        specialShotAvailable = true;
        // Afficher un message ou jouer un son pour indiquer que le tir spécial est disponible
        playSound(soundEffects.master);
        
        // Créer un élément visuel temporaire pour indiquer que le tir spécial est disponible
        const specialShotMessage = document.createElement("div");
        specialShotMessage.style.position = "absolute";
        specialShotMessage.style.left = "50%";
        specialShotMessage.style.top = "20%";
        specialShotMessage.style.transform = "translate(-50%, -50%)";
        specialShotMessage.style.color = "#FFFF00";
        specialShotMessage.style.fontSize = "24px";
        specialShotMessage.style.fontWeight = "bold";
        specialShotMessage.style.textShadow = "0 0 10px #FF0000";
        specialShotMessage.style.zIndex = "100";
        specialShotMessage.textContent = "GENKI-DAMA DISPONIBLE ! CLICK GAUCHE !!!";
        document.body.appendChild(specialShotMessage);
        
        // Supprimer le message après 3 secondes
        setTimeout(() => {
            document.body.removeChild(specialShotMessage);
        }, 3000);
    }
}

function activateSpecialShot() {
    // Vérifier si le tir spécial est disponible et n'est pas déjà en cours
    if (!specialShotAvailable || specialShotReady) return;
    
    // Marquer le tir spécial comme étant en préparation
    specialShotReady = true;
    
    // Désactiver temporairement les tirs normaux pendant l'animation du tir spécial
    const previousShootingState = shooting;
    shooting = false;
    
    // Créer une nouvelle balle spéciale
    const specialBullet = {
        x: starship.x + starship.width / 2 - 25, // Centré horizontalement (la moitié de la taille finale)
        y: starship.y - 10, // Juste devant le nez du vaisseau
        width: 1, // Taille initiale
        height: 1, // Taille initiale
        targetSize: 200, // Taille finale (diamètre)
        speed: 3, // Vitesse de déplacement (lente)
        growthRate: 2, // Vitesse de croissance
        isGrowing: true, // En phase de croissance
        damage: 50, // Dégâts élevés
        color: "cyan" // Couleur de base
    };
    
    // Ajouter la balle au tableau des balles spéciales
    specialBullets.push(specialBullet);
    
    // Créer un effet visuel pour l'activation
    for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 30;
        redPoints.push({
            x: starship.x + starship.width/2 + Math.cos(angle) * distance,
            y: starship.y + Math.sin(angle) * distance,
            isExplosion: true,
            vx: Math.cos(angle) * 2,
            vy: Math.sin(angle) * 2,
            life: 15 + Math.floor(Math.random() * 5),
            color: ["cyan", "white", "magenta"][Math.floor(Math.random() * 3)]
        });
    }
    
    // Jouer un son pour l'activation du tir spécial
    playSound(soundEffects.awesome);
    
    // Réactiver les tirs normaux après un délai
    setTimeout(() => {
        // Seulement si le joueur était en train de tirer avant
        if (previousShootingState) {
            shooting = true;
        }
    }, 600); // Attendre que la balle finisse sa croissance
    
    // Une fois que le tir spécial est lancé, réinitialiser les étoiles
    stars = [];
    
    // Le tir spécial n'est plus disponible jusqu'à ce que 5 nouvelles étoiles soient collectées
    specialShotAvailable = false;
}
function updateAndDrawSpecialShot() {
    if (gameManager.isPaused) return;
    
    for (let i = specialBullets.length - 1; i >= 0; i--) {
        const bullet = specialBullets[i];
        
        // Phase de croissance
        if (bullet.isGrowing) {
            bullet.width += bullet.growthRate;
            bullet.height += bullet.growthRate;
            
            // Si la balle a atteint sa taille cible
            if (bullet.width >= bullet.targetSize) {
                bullet.width = bullet.targetSize;
                bullet.height = bullet.targetSize;
                bullet.isGrowing = false;
            }
        } else {
            // Phase de mouvement
            bullet.y -= bullet.speed;
        }
        
        // Dessiner la balle
        ctx.save();
        // Créer un dégradé pour un effet plus impressionnant
        const gradient = ctx.createRadialGradient(
            bullet.x + bullet.width/2, bullet.y + bullet.height/2, 0,
            bullet.x + bullet.width/2, bullet.y + bullet.height/2, bullet.width/2
        );
        gradient.addColorStop(0, "white");
        gradient.addColorStop(0.3, "cyan");
        gradient.addColorStop(1, "magenta");
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = "magenta";
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(
            bullet.x + bullet.width/2,
            bullet.y + bullet.height/2,
            bullet.width/2,
            0,
            Math.PI * 2
        );
        ctx.fill();
        ctx.restore();
        
        // Vérifier les collisions avec les ennemis
        checkSpecialShotCollisions(bullet);
        
        // Supprimer les balles qui sortent de l'écran
        if (bullet.y + bullet.height < 0) {
            specialBullets.splice(i, 1);
            
            // Réinitialiser le tir spécial
            specialShotAvailable = false;
            specialShotReady = false;
            
            // Réinitialiser les étoiles
            stars = [];
        }
    }
}

function checkSpecialShotCollisions(bullet) {
    // Boucle à travers tous les ennemis pour détecter les collisions
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        // Calculer la distance entre le centre de la balle et le centre de l'ennemi
        const dx = (bullet.x + bullet.width/2) - (enemy.x + enemy.width/2);
        const dy = (bullet.y + bullet.height/2) - (enemy.y + enemy.height/2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Si la distance est inférieure à la somme des rayons, il y a collision
        if (distance < (bullet.width/2 + enemy.width/2)) {
            // Créer un effet d'explosion
            for (let j = 0; j < 20; j++) {
                redPoints.push({
                    x: enemy.x + Math.random() * enemy.width,
                    y: enemy.y + Math.random() * enemy.height,
                    isExplosion: true,
                    vx: (Math.random() * 2 - 1) * 3,
                    vy: (Math.random() * 2 - 1) * 3,
                    life: 20 + Math.floor(Math.random() * 10),
                    color: ["red", "orange", "yellow", "white"][Math.floor(Math.random() * 4)]
                });
            }
            
            // Supprimer l'ennemi
            enemies.splice(i, 1);
            
            // Augmenter le score
            enemiesKilled++;
            document.getElementById("enemiesKilledCount").innerText = enemiesKilled;
            
            // Jouer un son
            playSound(soundEffects.hit);
        }
    }
    
    // Vérifier également les collisions avec les balles ennemies
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const enemyBullet = enemyBullets[i];
        
        // Calculer la distance
        const dx = (bullet.x + bullet.width/2) - (enemyBullet.x + enemyBullet.width/2);
        const dy = (bullet.y + bullet.height/2) - (enemyBullet.y + enemyBullet.height/2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Si la distance est inférieure à la somme des rayons, il y a collision
        if (distance < (bullet.width/2 + enemyBullet.width/2)) {
            // Supprimer la balle ennemie
            enemyBullets.splice(i, 1);
        }
    }
}
function drawSimpleStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    const step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    
    for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
    }
    
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fillStyle = "gold";
    ctx.fill();
    ctx.strokeStyle = "orange";
    ctx.lineWidth = 2;
    ctx.stroke();
}



        // Chargement des images
        const thunderImgs = Array(3).fill().map(() => new Image());
thunderImgs.forEach((img, i) => img.src = `/img/thunder${i + 1}.jpg`);
        const starshipImg = new Image();
        const starship2Img = isMultiplayer ? new Image() : null;
        const starship3Img = isTriplePlayer ? new Image() : null;
        const bulletImg = new Image();
        const backgroundImg = new Image();
        backgroundImg.src = "/img/back1.png";
        const enemyImgs = Array(6).fill().map(() => new Image());
        const enemyBulletImgs = Array(3).fill().map(() => new Image());
        const livesImg = new Image();
        const powerUpImgs = Array(3).fill().map(() => new Image());

        // Configuration des chemins d'images
        starshipImg.src = getSelectedShip();
        if (isMultiplayer && starship2Img) starship2Img.src = getSelectedShipP2();
        if (isTriplePlayer && starship3Img) starship3Img.src = getSelectedShipP3();
        bulletImg.src = "/img/bullets1.jpg";
        enemyImgs.forEach((img, i) => img.src = `/img/enemy${i ? i + 1 : ""}.jpg`);
        enemyBulletImgs.forEach((img, i) => img.src = `/img/bullets${i + 2}.jpg`);
        livesImg.src = "/img/lives.jpg";
        powerUpImgs.forEach((img, i) => img.src = `/img/powerUp${i ? i : ""}.jpg`);

        // Classes
        class GameObject {
            constructor(x, y, speed = 1.5) {
                this.x = x;
                this.y = y;
                this.speed = speed;
                this.width = 30;
                this.height = 30;
                this.direction = {
                    x: (Math.random() * 2 - 1) * speed,
                    y: (Math.random() * 2 - 1) * speed
                };
            }

            moveRandomly(canvas) {
                this.x += this.direction.x;
                this.y += this.direction.y;

                if (this.x <= 0 || this.x >= canvas.width - this.width) {
                    this.direction.x *= -1;
                }
                if (this.y <= 0 || this.y >= canvas.height - this.height) {
                    this.direction.y *= -1;
                }

                if (Math.random() < 0.005) {
                    this.direction.x = (Math.random() * 2 - 1) * this.speed;
                    this.direction.y = (Math.random() * 2 - 1) * this.speed;
                }
            }
        }

        class BonusManager {
            constructor() {
                this.powerUps = [];
                this.lives = [];
            }

            addPowerUp(type) {
    if (this.powerUps.length >= 5) return;

    // Si le type n'est pas spécifié, on le détermine en fonction du stage
    if (type === undefined) {
        if (isStage2) {
            // En stage 2, possibilité d'obtenir le powerup.jpg (type 0) ou le powerup1.jpg (type 1)
            type = Math.floor(Math.random() * 2);
        } else {
            // En stage 1 ou autres, uniquement le powerup1.jpg (type 1)
            type = 1;
        }
    }

    this.powerUps.push({
        x: Math.random() * (canvas.width - 100) + 50,
        y: -50,
        width: 40,
        height: 40,
        speed: 1,
        type: type
    });
}

            addLife() {
                if (this.lives.length >= 3) return;

                this.lives.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: -50,
                    width: 40,
                    height: 40,
                    speed: 2
                });
            }

            update() {
                if (gameManager.isPaused) return;

                // Mise à jour des power-ups
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.y += powerUp.speed;
                    powerUp.x += Math.sin(Date.now() * 0.002) * 2;
                    powerUp.x = Math.max(0, Math.min(canvas.width - powerUp.width, powerUp.x));

                    if (powerUp.y >= canvas.height) {
                        this.powerUps.splice(i, 1);
                    }
                }

                // Mise à jour des vies
                for (let i = this.lives.length - 1; i >= 0; i--) {
                    const life = this.lives[i];
                    life.y += life.speed;
                    life.x += Math.sin(Date.now() * 0.001) * 1.5;
                    life.x = Math.max(0, Math.min(canvas.width - life.width, life.x));

                    if (life.y >= canvas.height) {
                        this.lives.splice(i, 1);
                    }
                }
            }

            draw(ctx) {
                // Dessin des power-ups
                this.powerUps.forEach(powerUp => {
                    try {
                        ctx.drawImage(
                            powerUpImgs[powerUp.type],
                            powerUp.x, powerUp.y,
                            powerUp.width, powerUp.height
                        );

                        if (Math.random() > 0.7) {
                            ctx.save();
                            ctx.globalAlpha = 0.3;
                            ctx.fillStyle = "#04fbac";
                            ctx.beginPath();
                            ctx.arc(
                                powerUp.x + powerUp.width/2,
                                powerUp.y + powerUp.height/2,
                                powerUp.width/2 + 5,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            ctx.restore();
                        }
                    } catch (error) {
                        console.error("Erreur lors du dessin d'un power-up:", error);
                    }
                });

                // Dessin des vies
                this.lives.forEach(life => {
                    try {
                        ctx.drawImage(
                            livesImg,
                            life.x, life.y,
                            life.width, life.height
                        );

                        const pulseFactor = Math.sin(Date.now() * 0.005) * 0.2 + 1;

                        ctx.save();
                        ctx.globalAlpha = 0.2;
                        ctx.fillStyle = "red";
                        ctx.beginPath();
                        ctx.arc(
                            life.x + life.width/2,
                            life.y + life.height/2,
                            life.width/2 * pulseFactor,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.restore();
                    } catch (error) {
                        console.error("Erreur lors du dessin d'une vie:", error);
                    }
                });
            }

            checkAllCollisions() {
                this.checkCollisions(
                    starship,
                    type => activatePowerUp(starship, type),
                    () => {
                        starship.lives++;
                        updatePlayerStats();
                        playSound(soundEffects.perfect);
                    }
                );

                if (isMultiplayer && starship2) {
                    this.checkCollisions(
                        starship2,
                        type => activatePowerUp(starship2, type),
                        () => {
                            starship2.lives++;
                            updatePlayerStats();
                            playSound(soundEffects.perfect);
                        }
                    );
                }

                if (isTriplePlayer && starship3) {
                    this.checkCollisions(
                        starship3,
                        type => activatePowerUp(starship3, type),
                        () => {
                            starship3.lives++;
                            updatePlayerStats();
                            playSound(soundEffects.perfect);
                        }
                    );
                }
            }

            checkCollisions(ship, handlePowerUp, handleLife) {
                if (!ship || !ship.isActive) return;

                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    if (checkCollision(ship, powerUp)) {
                        handlePowerUp(powerUp.type);
                        this.powerUps.splice(i, 1);
                    }
                }

                for (let i = this.lives.length - 1; i >= 0; i--) {
                    const life = this.lives[i];
                    if (checkCollision(ship, life)) {
                        handleLife();
                        this.lives.splice(i, 1);
                    }
                }
            }
        }

        class GameManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.isPaused = false;
                this.setupPauseControl();
            }

            setupPauseControl() {
                window.addEventListener("mousedown", (e) => {
    if (e.button === 0) {
        shooting = true;
        
        // Vérifier si le tir spécial est disponible
        if (specialShotAvailable && !specialShotReady && !gameManager.isPaused) {
            activateSpecialShot();
        } 
        // Sinon, c'est un tir normal
        else if (!gameManager.isPaused) {
            soundEffects.shoot.play().catch(() => {});
        }
    }
    // FORMATION ASSISTANTS - Clic droit
    else if (e.button === 2 && assistantShips.length > 0 && !gameManager.isPaused) {
        e.preventDefault(); // Empêcher le menu contextuel
        isFormationActive = !isFormationActive;
        
        if (isFormationActive) {
            formationPositions = calculateFormationPositions();
            console.log("🔺 Formation triangle activée");
        } else {
            console.log("🔄 Mode libre activé");
        }
        
        playSound(soundEffects.coin); // Son de confirmation
    }
});

// Empêcher le menu contextuel du clic droit
window.addEventListener("contextmenu", (e) => {
    e.preventDefault();
});

    window.addEventListener("keydown", (e) => {
        if (e.code === "Escape") {
            this.togglePause();
        }
    });
   
    // Double tap pour pause sur mobile
    if (isMobile) {
        let lastTap = 0;
        document.addEventListener('touchend', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 300 && tapLength > 0 && e.touches.length === 0) {
                this.togglePause();
                e.preventDefault();
            }
            lastTap = currentTime;
        });
    }
}

            togglePause() {
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                    soundEffects.shoot.pause();
                } else if (shooting && !starship.stunned) {
                    soundEffects.shoot.play();
                }
            }
            togglePause() {
    this.isPaused = !this.isPaused;
    if (this.isPaused) {
        soundEffects.shoot.pause();
        // Arrêter le tir continu si en pause
        if (touchShootInterval) {
            clearInterval(touchShootInterval);
            touchShootInterval = null;
        }
    } else if (shooting && !starship.stunned) {
        soundEffects.shoot.play();
        // Reprendre le tir si le doigt était sur l'écran
        if (touchActive && !touchShootInterval) {
            touchShootInterval = setInterval(shootBullet, 100);
        }
    }
}
            draw(ctx) {
                if (this.isPaused) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = "white";
                    ctx.font = "48px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText("PAUSE", canvas.width / 2, canvas.height / 2);
                }
            }
        }

        // Création des instances
        const gameManager = new GameManager(canvas);
        const bonusManager = new BonusManager();

        // Événements
        window.addEventListener("gamepadconnected", function(e) {
            console.log("Manette connectée à l'indice %d: %s. %d boutons, %d axes.",
                e.gamepad.index, e.gamepad.id,
                e.gamepad.buttons.length, e.gamepad.axes.length);
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
        });

        window.addEventListener("gamepaddisconnected", function(e) {
            if (gamepadIndex === e.gamepad.index) {
                gamepadConnected = false;
                gamepadIndex = null;
            }
        });

        // Contrôles clavier
        window.addEventListener("keydown", function(e) {
            if (isMultiplayer) {
                switch(e.code) {
                    case "ArrowUp": keyUp = true; break;
                    case "ArrowDown": keyDown = true; break;
                    case "ArrowLeft": keyLeft = true; break;
                    case "ArrowRight": keyRight = true; break;
                    case "Enter":
                        keySpace = true;
                        shooting2 = true;
                        if (!gameManager.isPaused && starship2) {
                            starship2.bullets.push({
                                x: starship2.x + starship2.width / 2 - 2.5,
                                y: starship2.y,
                                width: 5,
                                height: 10,
                                speed: 15,
                                player: 2
                            });
                        }
                        break;
                }
            }

            if (isTriplePlayer) {
                switch(e.code) {
                    case "KeyW": keyW = true; break;
                    case "KeyS": keyS = true; break;
                    case "KeyA": keyA = true; break;
                    case "KeyD": keyD = true; break;
                    case "KeyH":
                        keyE = true;
                        shooting3 = true;
                        if (!gameManager.isPaused && starship3) {
                            starship3.bullets.push({
                                x: starship3.x + starship3.width / 2 - 2.5,
                                y: starship3.y,
                                width: 5,
                                height: 10,
                                speed: 15,
                                player: 3
                            });
                        }
                        break;
                }
            }
        });

        window.addEventListener("keyup", function(e) {
            if (isMultiplayer) {
                switch(e.code) {
                    case "ArrowUp": keyUp = false; break;
                    case "ArrowDown": keyDown = false; break;
                    case "ArrowLeft": keyLeft = false; break;
                    case "ArrowRight": keyRight = false; break;
                    case "Enter":
                        keySpace = false;
                        shooting2 = false;
                        break;
                }
            }

            if (isTriplePlayer) {
                switch(e.code) {
                    case "KeyW": keyW = false; break;
                    case "KeyS": keyS = false; break;
                    case "KeyA": keyA = false; break;
                    case "KeyD": keyD = false; break;
                    case "KeyE":
                        keyE = false;
                        shooting3 = false;
                        break;
                }
            }
        });

        // Contrôles souris
        window.addEventListener("mousemove", (event) => {
            if (!gameManager.isPaused && !starship.stunned) {
                starship.x = Math.max(
                    0,
                    Math.min(
                        canvas.width - starship.width,
                        event.clientX - starship.width / 2
                    )
                );
                starship.y = Math.max(
                    0,
                    Math.min(
                        canvas.height - starship.height,
                        event.clientY - starship.height / 2 + 20
                    )
                );
            }
        });
// Contrôles tactiles
if (isMobile) {
    // Événements tactiles pour le vaisseau principal
    canvas.addEventListener("touchstart", function(e) {
        e.preventDefault();
        if (gameManager.isPaused) return;
       
        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;
       
        // Montrer l'indicateur de toucher
        touchIndicator.style.display = "block";
        touchIndicator.style.left = touchX + "px";
        touchIndicator.style.top = touchY + "px";
       
        // Mettre à jour la position du vaisseau
        updateStarshipPosition(touchX, touchY);
       
        // Commencer à tirer
        touchActive = true;
        shooting = true;
        if (!gameManager.isPaused) {
            soundEffects.shoot.play().catch(() => {});
        }
       
        // Configuration du tir continu
        if (!touchShootInterval) {
            touchShootInterval = setInterval(shootBullet, 100);
        }
    });

    canvas.addEventListener("touchmove", function(e) {
        e.preventDefault();
        if (gameManager.isPaused || !touchActive) return;
       
        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;
       
        // Déplacer l'indicateur de toucher
        touchIndicator.style.left = touchX + "px";
        touchIndicator.style.top = touchY + "px";
       
        // Mettre à jour la position du vaisseau
        updateStarshipPosition(touchX, touchY);
    });

    canvas.addEventListener("touchend", function(e) {
        e.preventDefault();
        touchActive = false;
        shooting = false;
        touchIndicator.style.display = "none";
       
        soundEffects.shoot.pause();
        soundEffects.shoot.currentTime = 0;
       
        // Arrêter le tir continu
        if (touchShootInterval) {
            clearInterval(touchShootInterval);
            touchShootInterval = null;
        }
    });

    canvas.addEventListener("touchcancel", function(e) {
        e.preventDefault();
        touchActive = false;
        shooting = false;
        touchIndicator.style.display = "none";
       
        soundEffects.shoot.pause();
        soundEffects.shoot.currentTime = 0;
       
        // Arrêter le tir continu
        if (touchShootInterval) {
            clearInterval(touchShootInterval);
            touchShootInterval = null;
        }
    });
}
        window.addEventListener("mousedown", (e) => {
            if (e.button === 0) {
                shooting = true;
                if (!gameManager.isPaused) {
                    soundEffects.shoot.play().catch(() => {});
                }
            }
        });

        window.addEventListener("mouseup", (e) => {
            if (e.button === 0) {
                shooting = false;
                soundEffects.shoot.pause();
                soundEffects.shoot.currentTime = 0;
            }
        });

        // Fonctions utilitaires
        function playSound(sound) {
            try {
                sound.currentTime = 0;
                sound.play().catch(error => {
                    console.warn("Impossible de jouer le son:", error);
                });
            } catch (error) {
                console.error("Erreur lors de la lecture du son:", error);
            }
        }
        function updateStarshipPosition(x, y) {
    if (!starship || !starship.isActive || starship.stunned) return;
   
    // Mémoriser la dernière position tactile
    lastTouchX = x;
    lastTouchY = y;
   
    // Assurer une position adéquate du vaisseau
    // On place le vaisseau légèrement au-dessus du doigt pour une meilleure visibilité
    const offsetY = 50; // Décalage vertical pour plus de visibilité
   
    starship.x = Math.max(
        0,
        Math.min(
            canvas.width - starship.width,
            x - starship.width / 2
        )
    );
   
    starship.y = Math.max(
        0,
        Math.min(
            canvas.height - starship.height,
            y - offsetY
        )
    );
}
function checkCollision(rect1, rect2) {
    // Vérification que les objets existent et ont des coordonnées valides
    if (!rect1 || !rect2 ||
        typeof rect1.x !== 'number' || typeof rect1.y !== 'number' ||
        typeof rect2.x !== 'number' || typeof rect2.y !== 'number' ||
        typeof rect1.width !== 'number' || typeof rect1.height !== 'number' ||
        typeof rect2.width !== 'number' || typeof rect2.height !== 'number') {
        return false;
    }

    // Utilisation de la méthode AABB (Axis-Aligned Bounding Box) plus précise
    return (rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y);
}
        function updatePlayerStats() {
            if (isMultiplayer) {
                document.getElementById("playerStats").style.display = "block";
                document.getElementById("p1Lives").textContent = starship.lives;

                if (starship2) {
                    document.getElementById("p2Lives").textContent = starship2.lives;
                }

                if (isTriplePlayer && starship3) {
                    document.getElementById("p3Lives").textContent = starship3.lives;
                }
            } else {
                document.getElementById("livesCount").textContent = starship.lives;
            }
        }

        function getSelectedShip() {
    const key = isMultiplayer ? 'vaisseauChoisiP1' : 'vaisseauChoisi';
    const vaisseauChoisi = localStorage.getItem(key);

            const vaisseauImages = {
                'Intercepteur': 'starship6.jpg',
                'Croiseur': 'starship1.jpg',
                'Destroyer': 'starship2.jpg',
                'Chasseur': 'starship3.jpg',
                'Éclaireur': 'starship4.jpg',
                'Bombardier': 'starship5.jpg',
                'aéronef': 'starship7.jpg'
            };

            if (vaisseauChoisi && vaisseauImages[vaisseauChoisi]) {
                return `/img/${vaisseauImages[vaisseauChoisi]}`;
            }

            return "/img/starship7.jpg";
        }

        function getSelectedShipP2() {
            const vaisseauChoisi = localStorage.getItem('vaisseauChoisiP2');

            const vaisseauImages = {
                'Intercepteur': 'starship6.jpg',
                'Croiseur': 'starship1.jpg',
                'Destroyer': 'starship2.jpg',
                'Chasseur': 'starship3.jpg',
                'Éclaireur': 'starship4.jpg',
                'Bombardier': 'starship5.jpg',
                'aéronef': 'starship7.jpg'
            };

            if (vaisseauChoisi && vaisseauImages[vaisseauChoisi]) {
                return `/img/${vaisseauImages[vaisseauChoisi]}`;
            }

            return "/img/starship6.jpg";
        }

        function getSelectedShipP3() {
            const vaisseauChoisi = localStorage.getItem('vaisseauChoisiP3');

            const vaisseauImages = {
                'Intercepteur': 'starship6.jpg',
                'Croiseur': 'starship1.jpg',
                'Destroyer': 'starship2.jpg',
                'Chasseur': 'starship3.jpg',
                'Éclaireur': 'starship4.jpg',
                'Bombardier': 'starship5.jpg',
                'aéronef': 'starship7.jpg'
            };

            if (vaisseauChoisi && vaisseauImages[vaisseauChoisi]) {
                return `/img/${vaisseauImages[vaisseauChoisi]}`;
            }

            return "/img/starship5.jpg";
        }

        function checkGameState() {
            if (!gameIsRunning) return;

            const currentTime = Date.now();
            const timeSinceLastKill = currentTime - lastKillTime;

            if (enemies.length > 0 && timeSinceLastKill > 10000 && enemies.length === lastEnemyCount) {
                enemies = enemies.slice(0, Math.max(5, Math.floor(enemies.length / 2)));
                lastKillTime = currentTime;
            }

            if (enemies.length > 40) {
                enemies = enemies.slice(0, 40);
            }
            if (enemyBullets.length > 60) {
                enemyBullets = enemyBullets.slice(0, 60);
            }
            if (redPoints.length > 100) {
                redPoints = redPoints.slice(0, 100);
            }

            lastEnemyCount = enemies.length;
            setTimeout(checkGameState, 5000);
        }

        function updateMultiplayerControls() {
            if (gameManager.isPaused) return;

            if (isMultiplayer && starship2 && !starship2.stunned) {
                if (gamepadConnected) {
                    try {
                        const gamepad = navigator.getGamepads()[gamepadIndex];
                        if (gamepad) {
                            const moveSpeed = 15; // Augmentation de la vitesse
                            const axisX = gamepad.axes[0];
                            const axisY = gamepad.axes[1];

                            if (Math.abs(axisX) > 0.1) {
                                starship2.x += axisX * moveSpeed;
                            }
                            if (Math.abs(axisY) > 0.1) {
                                starship2.y += axisY * moveSpeed;
                            }

                            if (gamepad.buttons[0].pressed && !shooting2) {
                                shooting2 = true;
                                starship2.bullets.push({
                                    x: starship2.x + starship2.width / 2 - 2.5,
                                    y: starship2.y,
                                    width: 5,
                                    height: 10,
                                    speed: 20,
                                    player: 2
                                });
                            } else if (!gamepad.buttons[0].pressed) {
                                shooting2 = false;
                            }
                        }
                    } catch (error) {
                        console.error("Erreur manette:", error);
                    }
                }

                const moveSpeed = 15;
                if (keyUp) starship2.y -= moveSpeed;
                if (keyDown) starship2.y += moveSpeed;
                if (keyLeft) starship2.x -= moveSpeed;
                if (keyRight) starship2.x += moveSpeed;

                starship2.x = Math.max(0, Math.min(canvas.width - starship2.width, starship2.x));
                starship2.y = Math.max(0, Math.min(canvas.height - starship2.height, starship2.y));
            }

            if (isTriplePlayer && starship3 && !starship3.stunned) {
                const moveSpeed = 15;
                if (keyW) starship3.y -= moveSpeed;
                if (keyS) starship3.y += moveSpeed;
                if (keyA) starship3.x -= moveSpeed;
                if (keyD) starship3.x += moveSpeed;

                starship3.x = Math.max(0, Math.min(canvas.width - starship3.width, starship3.x));
                starship3.y = Math.max(0, Math.min(canvas.height - starship3.height, starship3.y));
            }
        }
// CORRECTION 6: S'assurer que la fonction handleKill gère correctement les stages
function handleKill(playerNumber) {
    lastKillTime = Date.now();
    simultaneousKills++;
    enemiesKilled++;
    killsWithoutDeath++;
    document.getElementById("enemiesKilledCount").innerText = enemiesKilled;

    // Incrémenter le compteur d'ennemis détruits sans être touché
enemiesDestroyedWithoutHit++;

// Si 10 ennemis ont été détruits sans être touché, créer une étoile
if (enemiesDestroyedWithoutHit >= 10) {
    createStar();
}
   
    // Compteur différent selon le stage
    if (!isStage2 && !isStage3) {
        // Stage 1
        if (enemiesKilled === 200 && !bossActive) {
            createBoss();
        }
        else if (enemiesKilled % 30 === 0 && !miniBossActive && !bossActive) {
            createMiniBoss();
        }
    } else if (isStage2 && !isStage3) {
        // Stage 2
        stage2EnemiesKilled++;
        if (stage2EnemiesKilled === 200 && !bossActive) {
            createBoss2();
        }
        else if (stage2EnemiesKilled % 15 === 0 && !miniBossActive && !bossActive) {
            createMiniBoss(); // Apparaître plus fréquemment en stage 2
        }
    } else if (isStage3) {
        // Stage 3
        stage3EnemiesKilled++;
        console.log("Ennemis tués en stage 3:", stage3EnemiesKilled);
        
        // Réduire le nombre requis pour faire apparaître le boss
        if (stage3EnemiesKilled >= 200 && !bossActive) {
            createBoss3();
        }
        
        // Pour le mini-boss, on peut le faire apparaître plus tôt et plus fréquemment
        if (stage3EnemiesKilled % 15 === 0 && !miniBossActive && !bossActive) {
            createMiniBoss();
        }
    }

    // Le reste de la fonction reste inchangé...
    if (isMultiplayer) {
        switch (playerNumber) {
            case 1:
                const p1Kills = parseInt(document.getElementById("p1Kills").textContent) + 1;
                document.getElementById("p1Kills").textContent = p1Kills;
                const p1Points = parseInt(document.getElementById("p1Points").textContent) + 10;
                document.getElementById("p1Points").textContent = p1Points;
                break;
            case 2:
                const p2Kills = parseInt(document.getElementById("p2Kills").textContent) + 1;
                document.getElementById("p2Kills").textContent = p2Kills;
                const p2Points = parseInt(document.getElementById("p2Points").textContent) + 10;
                document.getElementById("p2Points").textContent = p2Points;
                break;
            case 3:
                const p3Kills = parseInt(document.getElementById("p3Kills").textContent) + 1;
                document.getElementById("p3Kills").textContent = p3Kills;
                const p3Points = parseInt(document.getElementById("p3Points").textContent) + 10;
                document.getElementById("p3Points").textContent = p3Points;
                break;
        }
    }

    if (killsWithoutDeath === 20) {
        playSound(soundEffects.brutal);
    } else if (killsWithoutDeath === 30) {
        playSound(soundEffects.super);
    } else if (killsWithoutDeath === 40) {
        playSound(soundEffects.master);
    } else if (killsWithoutDeath === 60) {
        playSound(soundEffects.awesome);
    }

    if (enemiesKilled % 30 === 0) {
        bonusManager.addPowerUp(2);
        playSound(soundEffects.king);
    } else if (enemiesKilled % powerUpFrequency === 0) {
        if (Math.random() < 0.5) {
            bonusManager.addPowerUp();
        } else {
            bonusManager.addLife();
        }
    }

    clearTimeout(killTimer);
    killTimer = setTimeout(() => {
        if (simultaneousKills === 2) {
            playSound(soundEffects.doubleKill);
        } else if (simultaneousKills >= 3) {
            playSound(soundEffects.tripleKill);
        }
        simultaneousKills = 0;
    }, 200);
}
        // CORRECTION 5: Modification de createBoss2 pour définir correctement les propriétés du boss
        function createBoss2() {
    console.log("Création du boss 2");
    if (bossActive) return;
   
    bossActive = true;
    bossHealth = 500; // Santé pour le boss du stage 2
   
    document.getElementById("bossHealthBar").style.display = "block";
    document.getElementById("bossHealthFill").style.width = "100%";
   
    boss = {
        x: canvas.width / 2 - 150, // Position ajustée pour centrer
        y: 50,
        width: 250, // Taille augmentée
        height: 250, // Taille augmentée
        vx: 0.5,
        vy: 0.5,
        movePattern: 0,
        moveTimer: 0,
        lastMoveChange: Date.now(),
        isBoss2: true
    };
   
    playSound(soundEffects.bossAppear);
    enemies = [];
    
    // Afficher un message pour le boss 2
    const stageTitle = document.getElementById("stageTitle");
    stageTitle.textContent = "BOSS FINAL !";
    stageTitle.style.display = "block";
    stageTitle.style.opacity = "0";
   
    // Animation de fade-in
    setTimeout(() => {
        stageTitle.style.opacity = "1";
       
        // Animation de fade-out après 2 secondes
        setTimeout(() => {
            stageTitle.style.opacity = "0";
           
            // Masquer l'élément après la transition
            setTimeout(() => {
                stageTitle.style.display = "none";
            }, 2000);
        }, 2000);
    }, 100);
}
function createBoss3() {
    console.log("Création du boss 3");
    if (bossActive) return;
   
    bossActive = true;
    bossHealth = 2000; // Santé élevée pour le boss du stage 3
   
    document.getElementById("bossHealthBar").style.display = "block";
    document.getElementById("bossHealthFill").style.width = "100%";
   
    boss = {
        x: canvas.width / 2 - 200, // Position centrée, ajustée pour la taille plus grande
        y: 100, // Un peu plus bas que les autres boss
        width: 450, // Deux fois plus large (200 -> 400)
        height: 450, // Deux fois plus haut (200 -> 400)
        vx: 0, // Ne se déplace pas horizontalement
        vy: 0, // Ne se déplace pas verticalement
        isBoss3: true, // Marqueur pour identifier que c'est le boss 3
        shootCount: 0, // Compteur pour alterner entre les types de tirs
        lastShootTime: Date.now(),
        shootSide: 0 // 0 = les deux côtés, 1 = côté gauche, 2 = côté droit
    };
   
    playSound(soundEffects.bossAppear);
    enemies = []; // Vider les ennemis
   
    // Afficher un message pour le boss 3
    const stageTitle = document.getElementById("stageTitle");
    stageTitle.textContent = "BOSS FINAL 3: ANNIHILATEUR";
    stageTitle.style.display = "block";
    stageTitle.style.opacity = "0";
   
    // Animation de fade-in
    setTimeout(() => {
        stageTitle.style.opacity = "1";
       
        // Animation de fade-out après 3 secondes
        setTimeout(() => {
            stageTitle.style.opacity = "0";
           
            // Masquer l'élément après la transition
            setTimeout(() => {
                stageTitle.style.display = "none";
            }, 2000);
        }, 3000);
    }, 100);
}


function updateBoss3() {
    if (!bossActive || !boss || !boss.isBoss3 || gameManager.isPaused) return;
    
    // Le boss reste au centre, donc pas de mouvement
    // Cependant, on s'assure qu'il reste bien centré en cas de redimensionnement
    boss.x = canvas.width / 2 - boss.width / 2;
    
    // Tirs périodiques
    const currentTime = Date.now();
    if (currentTime - boss.lastShootTime > 500) { // Tir toutes les secondes
        shootBoss3Bullets();
        boss.lastShootTime = currentTime;
        
        // Changer le côté de tir toutes les 5 secondes (5 tirs)
        if (boss.shootCount % 5 === 0) {
            // Rotation des côtés: 0 -> 1 -> 2 -> 0 (les deux, gauche, droite)
            boss.shootSide = (boss.shootSide + 1) % 3;
        }
    }
}
function shootBoss3Bullets() {
    if (!bossActive || !boss || !boss.isBoss3) return;
    
    boss.shootCount++;
    
    // Tirs normaux - maintenant 32 directions (2 fois plus nombreux)
    for (let i = 0; i < 32; i++) {
        const angle = (i * 11.25) * Math.PI / 180; // 360/32 = 11.25 degrés
        
        // Déterminer si le tir est dans le bon côté selon le mode de tir actuel
        let shouldShoot = true;
        if (boss.shootSide === 1) { // côté gauche
            shouldShoot = (angle >= Math.PI / 2 && angle <= 3 * Math.PI / 2);
        } else if (boss.shootSide === 2) { // côté droit
            shouldShoot = (angle <= Math.PI / 2 || angle >= 3 * Math.PI / 2);
        }
        
        if (shouldShoot) {
            const speed = 2; // Un peu plus rapide que boss2
            const vx = Math.cos(angle) * speed;
            const vy = Math.sin(angle) * speed;
           
            enemyBullets.push({
                x: boss.x + boss.width/2,
                y: boss.y + boss.height/2,
                width: 8,
                height: 8,
                speed: 0,
                vx: vx,
                vy: vy,
                type: 1, // Type de balle différent (magenta)
                isBoss3Bullet: true
            });
        }
    }
    
    // Une fois sur deux, tirer trois grosses bullets de 40px (2 fois plus grand que l'original)
    if (boss.shootCount % 2 === 0) {
        // Tirer 3 grosses balles dans des directions aléatoires
        for (let i = 0; i < 8; i++) {
            const randomAngle = Math.random() * Math.PI * 2;
            
            enemyBullets.push({
                x: boss.x + boss.width/2 - 20, // Centré (40px de diamètre)
                y: boss.y + boss.height/2 - 20,
                width: 30, // 40px de diamètre (2 fois plus grand que 20px)
                height: 30,
                speed: 0,
                vx: Math.cos(randomAngle) * 1, // Plus rapide
                vy: Math.sin(randomAngle) * 3,
                type: 2, // Type de balle (gold)
                isBoss3Bullet: true,
                isLargeBullet: true
            });
        }
    }
    
    playSound(soundEffects.shoot);
}


function activatePowerUp(ship, powerUpType) {
    if (powerUpType === 2) {
        try {
            gameManager.isPaused = true;
            videoContainer.style.display = "block";
            powerUpVideo.currentTime = 0;

            const playPromise = powerUpVideo.play();
            if (playPromise) {
                playPromise.catch(error => {
                    console.error("Erreur vidéo:", error);
                    endPowerUpVideo();
                });
            }

            powerUpVideo.onended = endPowerUpVideo;
        } catch (error) {
            console.error("Erreur powerup:", error);
            endPowerUpVideo();
        }
    } else if (powerUpType === 0) { // powerUp.jpg (type 0)
        // Activer l'éclair
        activateThunder(ship);
    } else if (powerUpType === 1) { // powerUp1.jpg (type 1)
        if (ship.powerUpTimeoutId) {
            clearTimeout(ship.powerUpTimeoutId);
            ship.powerUpTimeoutId = null;
        }

        // Incrémenter le niveau de powerUp
        ship.powerUpLevel = Math.min(9, ship.powerUpLevel + 1);

        ship.powerUpTimeoutId = setTimeout(() => {
            ship.powerUpLevel = Math.max(0, ship.powerUpLevel - 1);
            ship.powerUpTimeoutId = null;
        }, 6000);
    }
}
        function endPowerUpVideo() {
            videoContainer.style.display = "none";
            gameManager.isPaused = false;
            enemies = [];
            enemyBullets = [];

            starship.powerUpLevel = 3;
            if (isMultiplayer && starship2) starship2.powerUpLevel = 3;
            if (isTriplePlayer && starship3) starship3.powerUpLevel = 3;

            if (powerUpTimeoutId) {
                clearTimeout(powerUpTimeoutId);
            }

            powerUpTimeoutId = setTimeout(() => {
                starship.powerUpLevel = 0;
                if (isMultiplayer && starship2) starship2.powerUpLevel = 0;
                if (isTriplePlayer && starship3) starship3.powerUpLevel = 0;
                powerUpTimeoutId = null;
            }, 6000);
        }

        function stunPlayer(player, duration = 2000) {
            if (!player || !player.isActive) return;
           
            player.stunned = true;
           
            document.querySelectorAll("#stun-effect-player" + player.player).forEach(e => e.remove());
           
            const stunEffect = document.createElement("div");
            stunEffect.style.position = "absolute";
            stunEffect.style.left = player.x + "px";
            stunEffect.style.top = player.y + "px";
            stunEffect.style.width = player.width + "px";
            stunEffect.style.height = player.height + "px";
            stunEffect.style.border = "2px dashed yellow";
            stunEffect.style.borderRadius = "50%";
            stunEffect.style.boxShadow = "0 0 10px yellow";
            stunEffect.style.animation = "pulse 0.5s infinite alternate";
            stunEffect.style.zIndex = "5";
            stunEffect.id = "stun-effect-player" + player.player;
           
            document.body.appendChild(stunEffect);
           
            if (player.stunnedTimeout) {
                clearTimeout(player.stunnedTimeout);
            }
           
            player.stunnedTimeout = setTimeout(() => {
                player.stunned = false;
                document.querySelectorAll("#stun-effect-player" + player.player).forEach(e => e.remove());
            }, duration);
        }

        function activateShield(player, duration = 5000) { // Réduit de 10s à 5s
  // Du code existant concernant l'activation du bouclier
  player.shield = true;
  
  // Probablement du code qui crée un élément pour l'effet visuel
  // ...
  
  // Du code qui définit un timeout pour désactiver le bouclier
  player.shieldTimeout = setTimeout(() => {
    player.shield = false;
    // Plus de code ici...
  }, duration);
}
        function checkPlayerVsPlayerCollisions() {
            if (!isMultiplayer) return;

            const players = [starship];
            if (starship2) players.push(starship2);
            if (starship3) players.push(starship3);

            for (let i = 0; i < players.length; i++) {
                for (let j = i + 1; j < players.length; j++) {
                    const player1 = players[i];
                    const player2 = players[j];

                    if (!player1.isActive || !player2.isActive) continue;

                    player1.bullets.forEach((bullet, index) => {
                        if (checkCollision(bullet, player2) && !player2.shield) {
                            player1.bullets.splice(index, 1);
                            stunPlayer(player2);
                            playSound(soundEffects.hit);
                        }
                    });

                    player2.bullets.forEach((bullet, index) => {
                        if (checkCollision(bullet, player1) && !player1.shield) {
                            player2.bullets.splice(index, 1);
                            stunPlayer(player1);
                            playSound(soundEffects.hit);
                        }
                    });
                }
            }
        }

        function updateStunEffects() {
            [starship, starship2, starship3].filter(Boolean).forEach(player => {
                if (player.stunned) {
                    const effect = document.getElementById("stun-effect-player" + player.player);
                    if (effect) {
                        effect.style.left = player.x + "px";
                        effect.style.top = player.y + "px";
                    }
                }
               
                if (player.shield) {
                    const shield = document.getElementById("shield-effect-player" + player.player);
                    if (shield) {
                        shield.style.left = (player.x - 10) + "px";
                        shield.style.top = (player.y - 10) + "px";
                    }
                }
            });
        }

        // Fonctions pour le boss
        function createBoss() {
            if (bossActive) return;
           
            bossActive = true;
            bossHealth = 200; // Augmentation de la résistance à 500
           
            document.getElementById("bossHealthBar").style.display = "block";
            document.getElementById("bossHealthFill").style.width = "100%";
           
            boss = {
                x: canvas.width / 2 - 75,
                y: 50,
                width: 150,
                height: 150,
                vx: 1, // Augmentation de la vitesse
                vy: 1.5,
                rotation: 0,
                movePattern: 0,
                moveTimer: 0,
                lastMoveChange: Date.now()
            };
           
            playSound(soundEffects.bossAppear);
            enemies = [];
            ctx.globalAlpha = 0.7;
       

   
   
}

// Ajoutez cette fonction à votre code JavaScript pour corriger l'erreur
function updateAndDrawAssistantShip() {
    if (!assistantShipActive || !assistantShip || gameManager.isPaused) return;
    
    // Phase de mise à jour - gestion du mouvement et du comportement du vaisseau assistant
    
    // Si l'animation d'entrée est active, déplacer le vaisseau du bas vers la position cible
    if (assistantShip.isEntering) {
        assistantShip.y -= assistantShip.speed;
        
        // Si la position cible est atteinte, terminer la phase d'entrée
        if (assistantShip.y <= assistantShip.targetY) {
            assistantShip.y = assistantShip.targetY;
            assistantShip.isEntering = false;
        }
    } else {
        // Mouvement régulier - d'un côté à l'autre
        assistantShip.moveTimer += 0.01;
        
        // Déplacer la position basée sur une onde sinusoïdale pour un mouvement fluide
        assistantShip.x += Math.sin(assistantShip.moveTimer) * 2 * assistantShip.moveDirection;
        
        // S'assurer que le vaisseau reste dans les limites de l'écran
        if (assistantShip.x < 0) {
            assistantShip.x = 0;
            assistantShip.moveDirection *= -1;
        } else if (assistantShip.x + assistantShip.width > canvas.width) {
            assistantShip.x = canvas.width - assistantShip.width;
            assistantShip.moveDirection *= -1;
        }
        
        // Changer de direction aléatoirement de temps en temps
        if (Math.random() < 0.005) {
            assistantShip.moveDirection *= -1;
        }
        
        // Tirer automatiquement des balles
        const currentTime = Date.now();
        if (currentTime - assistantShip.lastShootTime > assistantShip.shootInterval) {
            // Créer 3 balles depuis le vaisseau assistant
            for (let i = -1; i <= 1; i++) {
                const bulletSize = 4;
                const bullet = {
                    x: assistantShip.x + assistantShip.width / 2 - bulletSize / 2 + (i * 8),
                    y: assistantShip.y,
                    width: bulletSize,
                    height: bulletSize,
                    speed: 12,
                    color: "#FFFF00", // Balles jaunes pour le vaisseau assistant
                    player: 1, // Associé au joueur 1 pour la détection de collision
                    isAssistantBullet: true
                };
                
                starship.bullets.push(bullet);
            }
            
            assistantShip.lastShootTime = currentTime;
        }
        
        // Activer le bouclier aléatoirement
        if (!assistantShip.shield.active && Math.random() < 0.001) {
            assistantShip.shield.active = true;
            assistantShip.shield.timer = Date.now();
        }
        
        // Mettre à jour le timer du bouclier
        if (assistantShip.shield.active) {
            if (Date.now() - assistantShip.shield.timer > assistantShip.shield.duration) {
                assistantShip.shield.active = false;
            }
        }
    }
    
    // Phase de dessin - rendu du vaisseau assistant et de ses effets
    
    // Dessiner le vaisseau assistant
    ctx.save();
    
    // Appliquer des effets visuels si le vaisseau a été touché
    if (assistantShip.isHit) {
        ctx.globalAlpha = 0.7;
        assistantShip.isHit = false;
    }
    
    // Dessiner l'image du vaisseau
    if (assistantShipImg.complete) {
        ctx.drawImage(
            assistantShipImg,
            assistantShip.x,
            assistantShip.y,
            assistantShip.width,
            assistantShip.height
        );
    } else {
        // Solution de secours si l'image n'est pas chargée
        ctx.fillStyle = "#FFFF00";
        ctx.fillRect(
            assistantShip.x,
            assistantShip.y,
            assistantShip.width,
            assistantShip.height
        );
    }
    
    // Dessiner le bouclier s'il est actif
    if (assistantShip.shield.active) {
        ctx.beginPath();
        ctx.arc(
            assistantShip.x + assistantShip.width / 2,
            assistantShip.y + assistantShip.height / 2,
            assistantShip.shield.radius,
            0,
            Math.PI * 2
        );
        
        // Créer un dégradé pour le bouclier
        const gradient = ctx.createRadialGradient(
            assistantShip.x + assistantShip.width / 2,
            assistantShip.y + assistantShip.height / 2,
            assistantShip.shield.radius * 0.7,
            assistantShip.x + assistantShip.width / 2,
            assistantShip.y + assistantShip.height / 2,
            assistantShip.shield.radius
        );
        
        gradient.addColorStop(0, "rgba(255, 255, 128, 0.1)");
        gradient.addColorStop(0.7, "rgba(255, 255, 128, 0.3)");
        gradient.addColorStop(1, "rgba(255, 255, 128, 0.5)");
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Ajouter une bordure au bouclier
        ctx.strokeStyle = "rgba(255, 255, 128, 0.8)";
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    // Ajoutez ces modifications à la fonction updateAndDrawAssistantShip
// vers la fin de la partie "Phase de mise à jour"

// Vérifier les collisions avec les balles ennemies
for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const bullet = enemyBullets[i];
    if (!bullet) continue;
    
    // Créer une zone de collision pour le vaisseau assistant
    const assistantRect = {
        x: assistantShip.x,
        y: assistantShip.y,
        width: assistantShip.width,
        height: assistantShip.height
    };
    
    // Vérifier la collision
    if (checkCollision(assistantRect, bullet)) {
        // Supprimer la balle ennemie
        enemyBullets.splice(i, 1);
        
        // Ne prendre des dégâts que si le bouclier n'est pas actif
        if (!assistantShip.shield.active) {
            // Effet visuel de touche
            assistantShip.isHit = true;
            
            // Réduire la santé
            assistantShip.health--;
            
            // Jouer un son
            playSound(soundEffects.hit);
            
            // Effets de particules
            for (let j = 0; j < 10; j++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                redPoints.push({
                    x: assistantShip.x + assistantShip.width/2 + Math.cos(angle) * 10,
                    y: assistantShip.y + assistantShip.height/2 + Math.sin(angle) * 10,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 10 + Math.floor(Math.random() * 5),
                    isExplosion: true,
                    color: "yellow" // Couleur jaune pour le vaisseau assistant
                });
            }
            
            // Vérifier si le vaisseau est détruit
            if (assistantShip.health <= 0) {
                // Créer une explosion finale
                for (let j = 0; j < 30; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;
                    redPoints.push({
                        x: assistantShip.x + Math.random() * assistantShip.width,
                        y: assistantShip.y + Math.random() * assistantShip.height,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 20 + Math.floor(Math.random() * 10),
                        isExplosion: true,
                        color: ["yellow", "orange", "white"][Math.floor(Math.random() * 3)]
                    });
                }
                
                // Désactiver le vaisseau assistant
                assistantShipActive = false;
                
                // Jouer un son de destruction
                playSound(soundEffects.explosion || soundEffects.hit);
                
                return; // Sortir de la fonction car le vaisseau est détruit
            }
        } else {
            // Si le bouclier est actif, créer un effet visuel de "rebond"
            const angle = Math.random() * Math.PI * 2;
            for (let j = 0; j < 5; j++) {
                redPoints.push({
                    x: bullet.x,
                    y: bullet.y,
                    vx: Math.cos(angle + j * Math.PI/4) * 2,
                    vy: Math.sin(angle + j * Math.PI/4) * 2,
                    life: 10,
                    isExplosion: true,
                    color: "cyan"
                });
            }
        }
    }
}

// Vérifier les collisions avec les power-ups
for (let i = bonusManager.powerUps.length - 1; i >= 0; i--) {
    const powerUp = bonusManager.powerUps[i];
    if (!powerUp) continue;
    
    if (checkCollision(assistantShip, powerUp)) {
        // Absorber le power-up
        if (powerUp.type === 0) {
            // Éclair - activer le bouclier du vaisseau assistant
            assistantShip.shield.active = true;
            assistantShip.shield.timer = Date.now();
            
            // Allonger la durée du bouclier
            assistantShip.shield.duration = 5000; // 5 secondes
        } else if (powerUp.type === 1) {
            // Tir amélioré - augmenter la cadence de tir
            assistantShip.shootInterval = Math.max(200, assistantShip.shootInterval - 100);
        } else if (powerUp.type === 2) {
            // Bonus de vie
            assistantShip.health = Math.min(5, assistantShip.health + 1);
        }
        
        // Jouer un son
        playSound(soundEffects.coin);
        
        // Supprimer le power-up
        bonusManager.powerUps.splice(i, 1);
        
        // Effet visuel
        for (let j = 0; j < 15; j++) {
            const angle = Math.random() * Math.PI * 2;
            redPoints.push({
                x: assistantShip.x + assistantShip.width/2,
                y: assistantShip.y + assistantShip.height/2,
                vx: Math.cos(angle) * 2,
                vy: Math.sin(angle) * 2,
                life: 15,
                isExplosion: true,
                color: ["cyan", "yellow", "white"][Math.floor(Math.random() * 3)]
            });
        }
    }
}

// Vérifier également les collisions avec les vies supplémentaires
for (let i = bonusManager.lives.length - 1; i >= 0; i--) {
    const life = bonusManager.lives[i];
    if (!life) continue;
    
    if (checkCollision(assistantShip, life)) {
        // Augmenter la santé du vaisseau assistant
        assistantShip.health = Math.min(5, assistantShip.health + 1);
        
        // Jouer un son
        playSound(soundEffects.perfect);
        
        // Supprimer la vie
        bonusManager.lives.splice(i, 1);
        
        // Effet visuel
        for (let j = 0; j < 15; j++) {
            const angle = Math.random() * Math.PI * 2;
            redPoints.push({
                x: assistantShip.x + assistantShip.width/2,
                y: assistantShip.y + assistantShip.height/2,
                vx: Math.cos(angle) * 2,
                vy: Math.sin(angle) * 2,
                life: 15,
                isExplosion: true,
                color: "red"
            });
        }
    }
}
    
    // Dessiner l'indicateur de santé
    for (let i = 0; i < assistantShip.health; i++) {
        ctx.fillStyle = "#04fbac";
        ctx.fillRect(
            assistantShip.x + (i * 15),
            assistantShip.y - 10,
            10,
            5
        );
    }
    
    ctx.restore();
}
        function updateBoss() {
            if (!bossActive || !boss || gameManager.isPaused) return;
           
            // Rotation continue
            boss.rotation += 2;
            if (boss.rotation >= 360) boss.rotation = 0;
           
            // Mouvement dynamique
            const currentTime = Date.now();
            if (currentTime - boss.lastMoveChange > 3000) {
                boss.movePattern = Math.floor(Math.random() * 4);
                boss.lastMoveChange = currentTime;
            }
           
            switch(boss.movePattern) {
                case 0: // Mouvement circulaire
                    boss.moveTimer += 0.02;
                    boss.x = canvas.width/2 + Math.cos(boss.moveTimer) * 200;
                    boss.y = canvas.height/4 + Math.sin(boss.moveTimer) * 100;
                    break;
                case 1: // Zigzag
                    boss.x += boss.vx;
                    if (boss.x <= 0 || boss.x + boss.width >= canvas.width) {
                        boss.vx *= -1;
                        boss.y += 50;
                        if (boss.y > canvas.height/2) boss.y = 50;
                    }
                    break;
                case 2: // Mouvement en 8
                    boss.moveTimer += 0.02;
                    boss.x = canvas.width/2 + Math.cos(boss.moveTimer) * 200;
                    boss.y = canvas.height/4 + Math.sin(boss.moveTimer * 2) * 100;
                    break;
                case 3: // Dash aléatoire
                    if (Math.random() < 0.02) {
                        boss.vx = (Math.random() - 0.5) * 8;
                        boss.vy = (Math.random() - 0.5) * 6;
                    }
                    boss.x += boss.vx;
                    boss.y += boss.vy;
                    break;
            }
           
            // Maintenir le boss dans les limites
            boss.x = Math.max(0, Math.min(canvas.width - boss.width, boss.x));
            boss.y = Math.max(0, Math.min(canvas.height/2 - boss.height, boss.y));
           
            // Tirs plus fréquents
            bossShootTimer++;
            if (bossShootTimer >= 30) { // Réduit à 30 frames (deux fois plus rapide)
                shootBossBullets();
                bossShootTimer = 0;
            }
        }

        function drawBoss() {
    if (!bossActive || !boss) return;
   
    ctx.save();
   
    // Opacité normale
    ctx.globalAlpha = 1;
    
    // Centrer le boss
    ctx.translate(boss.x + boss.width/2, boss.y + boss.height/2);
    
    // Dessiner le boss selon son type
    if (boss.isBoss3) {
        // Boss 3 - pas de rotation
        if (boss3Img.complete) {
            ctx.drawImage(boss3Img, -boss.width/2, -boss.height/2, boss.width, boss.height);
        } else {
            // Image de secours
            ctx.fillStyle = "blue";
            ctx.fillRect(-boss.width/2, -boss.height/2, boss.width, boss.height);
        }
    } else if (boss.isBoss2) {
        // Boss 2
        if (boss2Img.complete) {
            ctx.drawImage(boss2Img, -boss.width/2, -boss.height/2, boss.width, boss.height);
        } else {
            ctx.fillStyle = "purple";
            ctx.fillRect(-boss.width/2, -boss.height/2, boss.width, boss.height);
        }
    } else {
        // Boss 1
        ctx.rotate(boss.rotation * Math.PI / 180);
        if (bossImg.complete) {
            ctx.drawImage(bossImg, -boss.width/2, -boss.height/2, boss.width, boss.height);
        } else {
            ctx.fillStyle = "red";
            ctx.fillRect(-boss.width/2, -boss.height/2, boss.width, boss.height);
        }
    }
   
    ctx.restore();
    ctx.globalAlpha = 1.0; // Réinitialiser l'opacité
}
        function shootBossBullets() {
    if (!bossActive || !boss) return;
   
    const isBoss2 = boss.isBoss2 || false;
    const bulletSpeed = isBoss2 ? 1.5 : 1; // Boss 2 tire 50% plus vite
   
    // Tirer dans 16 directions
    for (let i = 0; i < 16; i++) {
        const angle = (i * 22.5) * Math.PI / 180; // 360/16 = 22.5 degrés
        const speed = bulletSpeed;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
       
        enemyBullets.push({
            x: boss.x + boss.width/2,
            y: boss.y + boss.height/2,
            width: 8,
            height: 8,
            speed: 0,
            vx: vx,
            vy: vy,
            type: isBoss2 ? 0 : 2 // Type de balle différent pour le boss 2
        });
    }
   
    // Ajouter des tirs verticaux supplémentaires
    // Tirs vers le bas de façon très explicite
    enemyBullets.push({
        x: boss.x + boss.width/2,
        y: boss.y + boss.height/2,
        width: 8,
        height: 8,
        speed: 5 * (isBoss2 ? 1.5 : 1),
        vx: 0,
        vy: 5 * (isBoss2 ? 1.5 : 1),
        type: isBoss2 ? 0 : 2
    });
   
    // Tirs vers le haut de façon très explicite
    enemyBullets.push({
        x: boss.x + boss.width/2,
        y: boss.y + boss.height/2,
        width: 8,
        height: 8,
        speed: 0,
        vx: 0,
        vy: -5 * (isBoss2 ? 1.5 : 1),
        type: isBoss2 ? 0 : 2
    });
   
    playSound(soundEffects.shoot);
}

function checkBossCollisions() {
    if (!bossActive || !boss) return;
   
    // Vérifier les collisions avec les balles des joueurs
    const checkPlayerBullets = (player) => {
        if (!player || !player.isActive) return;
       
        for (let i = player.bullets.length - 1; i >= 0; i--) {
            const bullet = player.bullets[i];
           
            // Rectangle de collision ajusté selon le type de boss
            const bossRect = {
                x: boss.isBoss3 ? boss.x : (boss.isBoss2 ? boss.x - boss.width/2 : boss.x),
                y: boss.isBoss3 ? boss.y : (boss.isBoss2 ? boss.y - boss.height/2 : boss.y),
                width: boss.isBoss3 ? boss.width : (boss.isBoss2 ? boss.width * 2 : boss.width),
                height: boss.isBoss3 ? boss.height : (boss.isBoss2 ? boss.height * 2 : boss.height)
            };
           
            if (checkCollision(bullet, bossRect)) {
                // Supprimer la balle
                player.bullets.splice(i, 1);
               
                // Effet de hit
                bossHitEffect = true;
                bossHitEffectTimer = 0;
               
                // Diminuer la vie du boss
                bossHealth--;
               
                // Mettre à jour la barre de vie
                const maxHealth = boss.isBoss3 ? 2000 : (boss.isBoss2 ? 1500 : 500);
                document.getElementById("bossHealthFill").style.width = (bossHealth / maxHealth * 100) + "%";
               
                playSound(soundEffects.bossHit);
               
                // Vérifier si le boss est détruit
                if (bossHealth <= 0) {
                    if (boss.isBoss3) {
                        defeatBoss3();
                    } else if (boss.isBoss2) {
                        defeatBoss2();
                    } else {
                        defeatBoss();
                    }
                }
            }
        }
    };
   
    // Vérifications pour chaque joueur
    checkPlayerBullets(starship);
    if (isMultiplayer && starship2) checkPlayerBullets(starship2);
    if (isTriplePlayer && starship3) checkPlayerBullets(starship3);
   
    // Collision entre le joueur et le boss
    const checkPlayerCollision = (player) => {
        if (!player || !player.isActive) return;
       
        const bossRect = {
            x: boss.isBoss3 ? boss.x : (boss.isBoss2 ? boss.x - boss.width/2 : boss.x),
            y: boss.isBoss3 ? boss.y : (boss.isBoss2 ? boss.y - boss.height/2 : boss.y),
            width: boss.isBoss3 ? boss.width : (boss.isBoss2 ? boss.width * 2 : boss.width),
            height: boss.isBoss3 ? boss.height : (boss.isBoss2 ? boss.height * 2 : boss.height)
        };
       
        if (checkCollision(player, bossRect) && !player.shield) {
            player.lives--;
            updatePlayerStats();
            
            for (let k = 0; k < 20; k++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                redPoints.push({
                    x: player.x + player.width/2,
                    y: player.y + player.height/2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 15 + Math.floor(Math.random() * 10),
                    isExplosion: true,
                    color: ["red", "orange", "yellow"][Math.floor(Math.random() * 3)]
                });
            }
            
            if (player.lives <= 0) {
                playerDeath(player);
            }
        }
    };
   
    checkPlayerCollision(starship);
    if (isMultiplayer && starship2) checkPlayerCollision(starship2);
    if (isTriplePlayer && starship3) checkPlayerCollision(starship3);
}
function defeatBoss() {
    // Jouer un son
    playSound(soundEffects.bossDeath);
   
    // Créer un effet d'explosion
    for (let i = 0; i < 150; i++) {
        redPoints.push({
            x: boss.x + Math.random() * boss.width,
            y: boss.y + Math.random() * boss.height
        });
    }
   
    // Désactiver le boss
    bossActive = false;
    boss = null;
   
    // Cacher la barre de vie
    document.getElementById("bossHealthBar").style.display = "none";
   
    // Réinitialiser l'opacité
    ctx.globalAlpha = 1.0;
   
    // Bonus de points
    enemiesKilled += 10;
    document.getElementById("enemiesKilledCount").innerText = enemiesKilled;
   
    // Bonus pour tous les joueurs actifs
    if (isMultiplayer) {
        const p1Points = parseInt(document.getElementById("p1Points").textContent) + 100;
        document.getElementById("p1Points").textContent = p1Points;
       
        if (starship2 && starship2.isActive) {
            const p2Points = parseInt(document.getElementById("p2Points").textContent) + 100;
            document.getElementById("p2Points").textContent = p2Points;
        }
       
        if (isTriplePlayer && starship3 && starship3.isActive) {
            const p3Points = parseInt(document.getElementById("p3Points").textContent) + 100;
            document.getElementById("p3Points").textContent = p3Points;
        }
    }
   
    if (!isStage2) {
        // Activer le fond d'écran défilant pour le Stage 2
        backgroundActive = true;
        const scrollingBg = document.getElementById("scrollingBackground");
        scrollingBg.style.display = "block";

        scrollingBg.style.filter = "none";
        scrollingBg.style.backgroundSize = "contain";
        scrollingBg.style.backgroundRepeat = "repeat-x";


        // Passer au stage 2
        isStage2 = true;
        stage2EnemiesKilled = 0;

        // Remplacer les images d'ennemis par les nouvelles (seulement pour le Stage 2)
        enemyImgs.forEach((img, i) => {
            img.src = `/img/enemy${i + 10}.jpg`; // enemy10 à enemy15
        });

        // Afficher le titre de stage
        const stageTitle = document.getElementById("stageTitle");
        stageTitle.style.display = "block";
        
        // Animation de fade-in
        setTimeout(() => {
            stageTitle.style.opacity = "1";
            
            // Animation de fade-out après 3 secondes
            setTimeout(() => {
                stageTitle.style.opacity = "0";
                
                // Masquer l'élément après la transition
                setTimeout(() => {
                    stageTitle.style.display = "none";
                }, 2000);
            }, 3000);
        }, 100);
    }

    // Ajouter quelques power-ups
    bonusManager.addPowerUp(2);
    bonusManager.addLife();
}
// Fonction pour créer le mini-boss
function createMiniBoss() {
    if (miniBossActive) return;
   
    miniBossActive = true;
    miniBosses = []; // Réinitialiser le tableau
    
    // Créer deux mini-boss seulement pour les stages 2 et 3
    const bossCount = (isStage2 || isStage3) ? 2 : 1;
    
    for (let i = 0; i < bossCount; i++) {
        // Positionner les mini-boss à gauche et à droite
        const xPosition = (i === 0) ? 
            canvas.width / 4 - 50 :  // Premier mini-boss à gauche
            canvas.width * 3/4 - 50; // Deuxième mini-boss à droite
        
        miniBosses.push({
            x: xPosition,
            y: 80,
            width: 100,
            height: 100,
            vx: 0.5 * (i === 0 ? 1 : -1), // Direction opposée pour le deuxième
            vy: 0.3,
            health: 50, // Santé individuelle pour chaque mini-boss
            lastShootTime: Date.now()
        });
    }
   
    // Jouer un son d'alerte pour l'apparition des mini-boss
    playSound(soundEffects.king);
}

// Fonction pour mettre à jour le mini-boss
function updateMiniBoss() {
    if (!miniBossActive || miniBosses.length === 0 || gameManager.isPaused) return;
   
    for (let i = 0; i < miniBosses.length; i++) {
        const miniBoss = miniBosses[i];
        
        // Mouvement lent
        miniBoss.x += miniBoss.vx;
        miniBoss.y += miniBoss.vy;
       
        // Rebondir aux bords
        if (miniBoss.x <= 0 || miniBoss.x + miniBoss.width >= canvas.width) {
            miniBoss.vx *= -1;
        }
        if (miniBoss.y <= 0 || miniBoss.y + miniBoss.height >= canvas.height / 2) {
            miniBoss.vy *= -1;
        }
       
        // Tir toutes les 3 secondes
        const currentTime = Date.now();
        if (currentTime - miniBoss.lastShootTime > 2000) {
            shootMiniBossBullets(miniBoss, i);
            miniBoss.lastShootTime = currentTime;
        }
    }
}

// Fonction pour dessiner le mini-boss
function drawMiniBoss() {
    if (!miniBossActive || miniBosses.length === 0) return;
   
    for (let i = 0; i < miniBosses.length; i++) {
        const miniBoss = miniBosses[i];
        
        ctx.save();
        
        // Dessiner le mini-boss
        if (miniBossImg.complete) {
            ctx.drawImage(miniBossImg, miniBoss.x, miniBoss.y, miniBoss.width, miniBoss.height);
        } else {
            // Image de secours si l'image n'est pas chargée
            ctx.fillStyle = i === 0 ? "orange" : "yellow"; // Couleurs différentes pour les distinguer
            ctx.fillRect(miniBoss.x, miniBoss.y, miniBoss.width, miniBoss.height);
        }
        
        // Afficher la santé du mini-boss
        ctx.fillStyle = "white";
        ctx.font = "14px Arial";
        ctx.fillText(miniBoss.health + "/50", miniBoss.x + miniBoss.width/2 - 20, miniBoss.y - 10);
        
        ctx.restore();
    }
}

// Fonction pour les tirs du mini-boss
function shootMiniBossBullets(miniBoss, index) {
    if (!miniBossActive || !miniBoss) return;
    
    // Créer une rangée de 5 lasers rouges
    for (let i = 0; i < 5; i++) {
        enemyBullets.push({
            x: miniBoss.x + (miniBoss.width / 5) * i,
            y: miniBoss.y + miniBoss.height,
            width: 5, // Largeur 5px
            height: 30, // Longueur 20px
            speed: 3, // Vitesse des lasers
            color: index === 0 ? "red" : "orange", // Couleur différente selon le mini-boss
            isMiniBossBullet: true // Pour l'identifier
        });
    }
    
    // Ajouter une boule rouge qui suit les lasers
    setTimeout(function() {
        // Créer une boule au centre du mini-boss
        enemyBullets.push({
            x: miniBoss.x + (miniBoss.width / 2) - 5, // Centré (10px de diamètre)
            y: miniBoss.y + miniBoss.height,
            width: 30, // Diamètre 10px
            height: 10, // Forme circulaire
            speed: 5, // Un peu plus lent que les lasers
            color: index === 0 ? "red" : "orange", // Couleur différente selon le mini-boss
            isMiniBossBullet: true, // Pour l'identifier
            isRedBall: true // Pour identifier spécifiquement la boule
        });
    }, 500); // Délai de 500ms après les lasers
    
    playSound(soundEffects.shoot);
}
// Fonction pour vérifier les collisions avec le mini-boss
function checkMiniBossCollisions() {
    if (!miniBossActive || miniBosses.length === 0) return;
   
    // Pour chaque joueur actif...
    [starship, starship2, starship3].filter(Boolean).forEach(player => {
        if (!player.isActive) return;
        
        // Pour chaque mini-boss...
        for (let i = miniBosses.length - 1; i >= 0; i--) {
            const miniBoss = miniBosses[i];
            
            // Vérifier les collisions avec les balles
            for (let j = player.bullets.length - 1; j >= 0; j--) {
                const bullet = player.bullets[j];
                
                if (checkCollision(bullet, miniBoss)) {
                    // Supprimer la balle
                    player.bullets.splice(j, 1);
                    
                    // Réduire la santé du mini-boss
                    miniBoss.health--;
                    
                    // Son de coup
                    playSound(soundEffects.hit);
                    
                    // Vérifier si ce mini-boss est détruit
                    if (miniBoss.health <= 0) {
                        // Créer un effet d'explosion
                        for (let k = 0; k < 50; k++) {
                            redPoints.push({
                                x: miniBoss.x + Math.random() * miniBoss.width,
                                y: miniBoss.y + Math.random() * miniBoss.height,
                                isExplosion: true,
                                vx: (Math.random() * 2 - 1) * 2,
                                vy: (Math.random() * 2 - 1) * 2,
                                life: 20 + Math.floor(Math.random() * 10),
                                color: ["red", "orange", "yellow"][Math.floor(Math.random() * 3)]
                            });
                        }
                        
                        // Supprimer ce mini-boss
                        miniBosses.splice(i, 1);
                        
                        // Points pour le joueur
                        coins += 15;
                        document.getElementById("coinsCount").textContent = coins.toFixed(1);
                        
                        // Si tous les mini-boss sont détruits, désactiver complètement
                        if (miniBosses.length === 0) {
                            defeatMiniBoss();
                        }
                        
                        break;
                    }
                }
            }
            
            // Vérifier si le mini-boss existe encore (il pourrait avoir été détruit)
            if (i >= miniBosses.length) continue;
            
            // Vérifier si le joueur touche le mini-boss
            if (checkCollision(player, miniBosses[i])) {
                if (!player.shield) {
                    enemiesDestroyedWithoutHit = 0; // Réinitialiser le compteur
                    player.lives--;
                    updatePlayerStats();
                    
                    if (player.lives <= 0) {
                        playerDeath(player);
                    }
                }
            }
        }
    });
}
// Fonction pour la défaite du mini-boss
function defeatMiniBoss() {
    // Jouer un son
    playSound(soundEffects.perfect);
   
    // Désactiver le mini-boss
    miniBossActive = false;
    miniBosses = [];
   
    // Bonus points
    coins += 30;
    document.getElementById("coinsCount").textContent = coins.toFixed(1);
    
    // Donner des power-ups
    bonusManager.addPowerUp();
    bonusManager.addLife();
}
function shootBullet() {
    if (gameManager.isPaused) return;

    [
        { ship: starship, isShooting: shooting },
        { ship: starship2, isShooting: shooting2 },
        { ship: starship3, isShooting: shooting3 }
    ].filter(({ ship }) => ship && ship.isActive).forEach(({ ship, isShooting }) => {
        if (!isShooting) return;

        // Définir les différentes rangées de tirs que nous allons utiliser
        const rows = [
            // Rangée 1 - Niveau 0
            {
                offsets: [0],
                y: ship.y,
                speed: 20,
                color: "#00FFFF" // Cyan
            },
            // Rangée 2 - Niveau 1
            {
                offsets: [-10, 0, 10],
                y: ship.y,
                speed: 18,
                color: "#00FFFF" // Cyan
            },
            // Rangée 3 - Niveau 2
            {
                offsets: [-15, -5, 5, 15],
                y: ship.y - 4,
                speed: 16,
                color: "#FF00FF" // Magenta
            },
            // Rangée 4 - Niveau 3
            {
                offsets: [-20, -10, 0, 10, 20],
                y: ship.y - 8,
                speed: 14,
                color: "#00FFFF" // Cyan
            },
            // Rangée 5 - Niveau 4
            {
                offsets: [-30, -20, -10, 0, 10, 20, 30],
                y: ship.y - 12,
                speed: 12,
                color: "#FF00FF" // Magenta
            },
            // Rangée 6 - Niveau 5
            {
                offsets: [-40, -30, -20, -10, 0, 10, 20, 30, 40],
                y: ship.y - 16,
                speed: 10,
                color: "#00FFFF" // Cyan
            }
           
        ];

        // Déterminer combien de rangées utiliser en fonction du niveau de puissance
        const numRows = ship.powerUpLevel + 1;
        
        // Limiter à 9 rangées maximum
        const rowsToUse = rows.slice(0, Math.min(numRows, 9));
        
        // Créer les balles pour chaque rangée
        rowsToUse.forEach(row => {
            row.offsets.forEach(xOffset => {
                ship.bullets.push({
                    x: ship.x + ship.width / 2 + xOffset,
                    y: row.y,
                    width: 4,
                    height: 4,
                    speed: row.speed,
                    player: ship.player,
                    color: row.color
                });
            });
        });

        // Limiter le nombre de balles pour éviter les problèmes de performance
        if (ship.bullets.length > 1000) {
            ship.bullets = ship.bullets.slice(-1000);
        }
    });
}
function shootEnemyBullets() {
    if (gameManager.isPaused) return;

    const maxNewBullets = 10;
    let newBullets = 0;

    for (let i = 0; i < enemies.length && newBullets < maxNewBullets; i++) {
        const enemy = enemies[i];

        if (Math.random() > 0.2) continue;

       // Cas spécial pour enemy8 - tire une boule de chaque côté
if (enemy.type === 7) { // enemy8 (index commence à 0)
    // Boule gauche
    enemyBullets.push({
        x: enemy.x - 15, // À gauche de l'ennemi
        y: enemy.y + enemy.height/2 - 7.5, // Centré verticalement
        width: 15, // Diamètre de 15px
        height: 15, // Pour garder un cercle
        speed: 0,
        vx: -2,
    vy: 0,
    isSpecialEnemyBullet: true, // Nouvelle propriété
    enemyType: 8, // Indiquer quel type d'ennemi a tiré
        color: "cyan", // La couleur de ses propres balles
        isMiniBossBullet: true, // Pour utiliser le rendu spécial
        isRedBall: true, // Pour qu'il soit rendu comme une boule
        type: 0
    });
 
    // Boule droite
    enemyBullets.push({
        x: enemy.x + enemy.width, // À droite de l'ennemi
        y: enemy.y + enemy.height/2 - 7.5, // Centré verticalement
        width: 15, // Diamètre de 15px
        height: 15, // Pour garder un cercle
        speed: 0,
        vx: -2,
    vy: 0,
    isSpecialEnemyBullet: true, // Nouvelle propriété
    enemyType: 8, // Indiquer quel type d'ennemi a tiré
        color: "cyan",
        isMiniBossBullet: true,
        isRedBall: true,
        type: 0
    });
    
    playSound(soundEffects.shoot);
}
        // Cas spécial pour enemy12 - tir horizontal
        else if (enemy.type === 11) { // enemy12 (index commence à 0)
            // Tir vers la gauche
            enemyBullets.push({
                x: enemy.x,
                y: enemy.y + enemy.height / 2,
                width: 15,
                height: 15,
                speed: 0,
                vx: -3 * enemyBulletSpeedMultiplier,
    vy: 0,
    isSpecialEnemyBullet: true, // Nouvelle propriété
    enemyType: 12, // Indiquer quel type d'ennemi a tiré
                type: 2 // Type 2 pour la couleur
            });
            
            // Tir vers la droite
            enemyBullets.push({
                x: enemy.x + enemy.width,
                y: enemy.y + enemy.height / 2,
                width: 15,
                height: 15,
                speed: 0,
                vx: -3 * enemyBulletSpeedMultiplier,
    vy: 0,
    isSpecialEnemyBullet: true, // Nouvelle propriété
    enemyType: 12, // Indiquer quel type d'ennemi a tiré
                type: 2 // Type 2 pour la couleur
            });
        } 
        // Traitement normal pour les autres types d'ennemis
        else if (enemy.type === 1) {
            enemyBullets.push(
                {
                    x: enemy.x,
                    y: enemy.y + enemy.height / 2,
                    width: 4, // Diamètre 4px
                    height: 4, // Pour garder un cercle
                    speed: 0,
                    vx: -3 * enemyBulletSpeedMultiplier,
                    type: 1
                },
                {
                    x: enemy.x + enemy.width,
                    y: enemy.y + enemy.height / 2,
                    width: 4, // Diamètre 4px
                    height: 4, // Pour garder un cercle
                    speed: 0,
                    vx: 3 * enemyBulletSpeedMultiplier,
                    type: 1
                }
            );
        } else {
            // Tir normal vers le bas
            enemyBullets.push({
                x: enemy.x + enemy.width / 2 - 2, // Centré (4px de diamètre)
                y: enemy.y + enemy.height,
                width: 4, // Diamètre 4px
                height: 4, // Pour garder un cercle
                speed: 3 * enemyBulletSpeedMultiplier,
                type: Math.floor(Math.random() * 3)
            });
           
            // Tir vers l'arrière (vers le haut) uniquement en stage 2
            if (isStage2) {
                enemyBullets.push({
                    x: enemy.x + enemy.width / 2 - 2, // Centré (4px de diamètre)
                    y: enemy.y,
                    width: 4, // Diamètre 4px
                    height: 4, // Pour garder un cercle
                    speed: -3 * enemyBulletSpeedMultiplier, // Vitesse négative pour aller vers le haut
                    type: Math.floor(Math.random() * 3)
                });
            }
        }

        newBullets++;
    }

    if (enemyBullets.length > 100) {
        enemyBullets = enemyBullets.slice(-100);
    }
}

        function generateEnemies() {
            if (gameManager.isPaused) return;

            if (enemies.length > 30) {
                return;
            }

            const count = Math.min(7, 30 - enemies.length);

            for (let i = 0; i < count; i++) {
                enemies.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height / 3),
                    width: 60,
                    height: 60,
                    vx: (Math.random() * 2 - 1) * 2,
                    vy: Math.random() * 1.5,
                    type: Math.floor(Math.random() * 6)
                });
            }
        }

        function drawStarship() {
    const drawPlayer = (player, img) => {
        if (!player || !player.isActive) return;

        if (img && img.complete && img.naturalWidth > 0) {
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
           
            // Rotation uniquement pour le joueur 1
            if (player === starship) {
                if (player.x !== lastShipX) {
                    const moveDirection = player.x - lastShipX;
                    if (moveDirection < 0) {
                        shipRotation = Math.max(-maxRotation, shipRotation - rotationSpeed);
                    } else if (moveDirection > 0) {
                        shipRotation = Math.min(maxRotation, shipRotation + rotationSpeed);
                    }
                    lastShipX = player.x;
                } else {
                    if (shipRotation > 0) {
                        shipRotation = Math.max(0, shipRotation - rotationSpeed/2);
                    } else if (shipRotation < 0) {
                        shipRotation = Math.min(0, shipRotation + rotationSpeed/2);
                    }
                }
                ctx.rotate(shipRotation * Math.PI / 180);
            }
           
            ctx.drawImage(
                img,
                -player.width/2,
                -player.height/2,
                player.width,
                player.height
            );
            ctx.restore();
        } else {
            const colors = {
                1: "#04fbac",
                2: "#FF7F50",
                3: "#FFFF50"
            };
            ctx.fillStyle = colors[player.player];
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
    };

    drawPlayer(starship, starshipImg);
    if (isMultiplayer) drawPlayer(starship2, starship2Img);
    if (isTriplePlayer) drawPlayer(starship3, starship3Img);
}

function drawBullets() {
    const drawPlayerBullets = (player) => {
        if (!player || !player.isActive) return;

        player.bullets = player.bullets.filter(bullet => {
            const isOnScreen = bullet.y > -20 && bullet.y < canvas.height + 20 &&
                             bullet.x > -20 && bullet.x < canvas.width + 20;

            if (isOnScreen) {
                // Utiliser la couleur de la balle si disponible, sinon utiliser la couleur du joueur
                let bulletColor = bullet.color;
                if (!bulletColor) {
                    // Couleurs des joueurs par défaut
                    if (player.player === 1) bulletColor = "#04fbac"; // Vert-bleu
                    else if (player.player === 2) bulletColor = "#FF7F50"; // Orange
                    else if (player.player === 3) bulletColor = "#FFFF50"; // Jaune
                    else bulletColor = "white";
                }
                
                // Dessiner une boule avec la couleur spécifiée
                ctx.save();
                ctx.fillStyle = bulletColor;
                ctx.shadowColor = bulletColor;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(
                    bullet.x + bullet.width/2, 
                    bullet.y + bullet.width/2, 
                    bullet.width/2, // Rayon = moitié de la largeur
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
                ctx.restore();

                // Mettre à jour la position
                if (bullet.vx !== undefined && bullet.vy !== undefined) {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                } else {
                    bullet.y -= bullet.speed;
                }
            }

            return isOnScreen;
        });
    };

    drawPlayerBullets(starship);
    if (isMultiplayer) drawPlayerBullets(starship2);
    if (isTriplePlayer) drawPlayerBullets(starship3);
}

          
        function drawEnemies() {
            enemies = enemies.filter(enemy => {
                try {
                    ctx.drawImage(enemyImgs[enemy.type], enemy.x, enemy.y, enemy.width, enemy.height);

                    enemy.x += enemy.vx;
                    enemy.y += enemy.vy;

                    if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
                        enemy.vx *= -1;
                    }
                    if (enemy.y <= 0) {
                        enemy.vy *= -1;
                    }

                    return enemy.y < canvas.height;
                } catch (error) {
                    console.error("Erreur lors du dessin d'un ennemi:", error);
                    return false;
                }
            });
        }

        function drawEnemyBullets() {
    enemyBullets = enemyBullets.filter(bullet => {
        try {
            if (bullet.isMiniBossBullet) {
                // Sauvegarde le contexte
                ctx.save();
                
                if (bullet.isRedBall) {
                    // Dessiner une boule avec la taille spécifiée
                    ctx.fillStyle = bullet.color || "red";
                    ctx.shadowColor = bullet.color || "red";
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(
                        bullet.x + bullet.width/2, 
                        bullet.y + bullet.height/2, 
                        bullet.width/2, // Utiliser la taille définie dans le bullet
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                } else {
                    // Dessiner les lasers du mini-boss
                    ctx.fillStyle = bullet.color || "red";
                    ctx.shadowColor = bullet.color || "red";
                    ctx.shadowBlur = 10;
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                }
                
                ctx.restore();
            } else {
                // Pour les balles ennemies normales, respecter la taille définie
                let bulletColor;
                if (bullet.type === 0) bulletColor = "cyan"; 
                else if (bullet.type === 1) bulletColor = "magenta";
                else if (bullet.type === 2) bulletColor = "gold";
                else bulletColor = "white";
                
                // Dessiner une boule colorée avec la taille définie
                ctx.save();
                ctx.fillStyle = bulletColor;
                ctx.shadowColor = bulletColor;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(
                    bullet.x + bullet.width/2, 
                    bullet.y + bullet.height/2, 
                    bullet.width/2, // Utiliser la taille définie dans le bullet
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
                ctx.restore();
            }
            
            // Mettre à jour la position
            if (bullet.vx !== undefined) {
                bullet.x += bullet.vx;
            }
           
            if (bullet.vy !== undefined) {
                bullet.y += bullet.vy;
            } else if (bullet.speed) {
                bullet.y += bullet.speed;
            }

            return bullet.y < canvas.height && bullet.y > 0 && bullet.x > 0 && bullet.x < canvas.width;
        } catch (error) {
            console.error("Erreur lors du dessin d'une balle ennemie:", error);
            return false;
        }
    });
}
function drawRedPoints() {
    if (redPoints.length > 500) {
        redPoints = redPoints.slice(0, 500);
    }
   
    redPoints = redPoints.filter((point) => {
        // Si c'est une particule d'explosion (non récoltable)
        if (point.isExplosion) {
            ctx.fillStyle = point.color || "red";
            ctx.fillRect(point.x, point.y, 3, 3); // Un peu plus grandes
            
            // Mettre à jour la position avec la vélocité
            point.x += point.vx;
            point.y += point.vy;
            
            // Ralentir progressivement
            point.vx *= 0.95;
            point.vy *= 0.95;
            
            // Réduire la durée de vie
            point.life--;
            
            return point.life > 0;
        } 
        // Points récoltables - comportement d'origine
        else {
            ctx.fillStyle = "red";
            ctx.fillRect(point.x, point.y, 2, 2);
            point.y += 1;
            
            let attractedToPlayer = false;
            let minDistance = Number.MAX_VALUE;
            let attraction = { x: 0, y: 0 };
            
            // Vérifier attraction au joueur 1
            if (starship && starship.isActive) {
                const dx = starship.x + starship.width/2 - point.x;
                const dy = starship.y + starship.height/2 - point.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100 && distance < minDistance) {
                    attraction.x = dx / distance * 3;
                    attraction.y = dy / distance * 3;
                    minDistance = distance;
                    attractedToPlayer = true;
                    
                    if (distance < 30) {
                        coins += 0.5;
                        document.getElementById("coinsCount").textContent = coins.toFixed(1);
                        playSound(soundEffects.coin);
                        starship.redPointsCollected++;
                        // Mettre à jour l'affichage
document.getElementById("redPointsCount").textContent = starship.redPointsCollected;
                        // CORRECTION: Compteur global unique (pas de double incrémentation)
                        redPointsTotal++;

                        // CORRECTION: Logique de création d'assistants gérée ailleurs
                        
                    if (starship.redPointsCollected >= 20) {
    console.log("🛡️ Activation du bouclier pour le joueur 1 - Points: " + starship.redPointsCollected);
    console.log("🛡️ Shield actuel:", starship.shield);
    
    // CORRECTION: Forcer la désactivation du shield précédent si il existe
    if (starship.shieldTimeout) {
        clearTimeout(starship.shieldTimeout);
        starship.shieldTimeout = null;
    }
    
    activateShield(starship);
    starship.redPointsCollected = 0; // Réinitialiser le compteur
    
    console.log("🛡️ Compteur réinitialisé à : " + starship.redPointsCollected);
    console.log("🛡️ Nouveau shield actuel:", starship.shield);
}
                        
                        return false; // supprime ce point
                    }
                }
            }
            
            // [Le reste du code d'attraction pour les joueurs 2 et 3]
            
            // Appliquer l'attraction si nécessaire
            if (attractedToPlayer) {
                point.x += attraction.x;
                point.y += attraction.y;
            }
            
            // CORRECTION: Vérifier attraction aux assistants (avec compteurs individuels)
            if (!attractedToPlayer) {
                for (let i = 0; i < assistantShips.length; i++) {
                    const assistant = assistantShips[i];
                    if (assistant && !assistant.isEntering) {
                        const dx = assistant.x + assistant.width/2 - point.x;
                        const dy = assistant.y + assistant.height/2 - point.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 80 && distance < minDistance) {
                            attraction.x = dx / distance * 2;
                            attraction.y = dy / distance * 2;
                            minDistance = distance;
                            attractedToPlayer = true;
                            
                            if (distance < 25) {
                                coins += 0.3;
                                document.getElementById("coinsCount").textContent = coins.toFixed(1);
                                playSound(soundEffects.coin);
                                
                                // CORRECTION: Compteur individuel pour chaque assistant
                                assistant.redPointsCollected++;
                                redPointsTotal++;
                                
                                // Vérifier activation du bouclier pour cet assistant
                                if (assistant.redPointsCollected >= 15) {
                                    console.log(`🛡️ Assistant ${i+1} active son bouclier - Points: ${assistant.redPointsCollected}`);
                                    
                                    // Activer le bouclier de l'assistant
                                    assistant.shield.active = true;
                                    assistant.shield.timer = 0;
                                    
                                    // Réinitialiser le compteur
                                    assistant.redPointsCollected = 0;
                                }
                                
                                return false; // supprime ce point
                            }
                        }
                    }
                }
            }
            
            // Appliquer l'attraction si nécessaire
            if (attractedToPlayer) {
                point.x += attraction.x;
                point.y += attraction.y;
            }
            
            // Conserver le point s'il est toujours dans l'écran
            return point.y <= canvas.height;
        }
    });
}
function activateShield(player, duration = 5000) { // Réduit de 10s à 5s
  if (!player || !player.isActive) return;
  
  player.shield = true;
  
  // Créer un élément pour l'effet de bouclier si nécessaire
  let shieldEffect = document.getElementById("shield-effect-player" + player.player);
  if (!shieldEffect) {
    shieldEffect = document.createElement("div");
    shieldEffect.id = "shield-effect-player" + player.player;
    shieldEffect.className = "shield-effect";
    shieldEffect.style.width = (player.width + 20) + "px";
    shieldEffect.style.height = (player.height + 20) + "px";
    document.body.appendChild(shieldEffect);
  }
  
  // Déterminer la couleur du bouclier selon le joueur
  shieldEffect.style.color = player.player === 1 ? "#04fbac" :
                           player.player === 2 ? "#FF7F50" : "#FFFF50";

  // Initialiser les particules pour ce joueur
  createShieldParticles(player);
  
  // Nettoyer tout timeout existant
 // Désactiver le bouclier après la durée spécifiée
player.shieldTimeout = setTimeout(() => {
    player.shield = false;
    // Shield désactivé silencieusement
}, duration);
// Vérifier aussi pour le joueur 2
if (isMultiplayer && starship2 && starship2.isActive) {
    // [Le code existant pour le joueur 2]
    
    if (distance < 30) {
        coins += 0.5;
        document.getElementById("coinsCount").textContent = coins.toFixed(1);
        playSound(soundEffects.coin);
        starship2.redPointsCollected++;
        redPointsTotal++;
        
        // Vérifier l'activation du bouclier
        if (starship2.redPointsCollected >= 100) {
            console.log("🛡️ Activation du bouclier pour le joueur 2 - Points: " + starship2.redPointsCollected);
            
            // CORRECTION: Forcer la désactivation du shield précédent si il existe
            if (starship2.shieldTimeout) {
                clearTimeout(starship2.shieldTimeout);
                starship2.shieldTimeout = null;
            }
            
            activateShield(starship2);
            starship2.redPointsCollected = 0;
            console.log("🛡️ Shield joueur 2 activé, compteur réinitialisé");
        }
        
        return false;
    }
}

// Et pareil pour le joueur 3
if (isTriplePlayer && starship3 && starship3.isActive) {
    // [Le code existant pour le joueur 3]
    
    if (distance < 30) {
        coins += 0.5;
        document.getElementById("coinsCount").textContent = coins.toFixed(1);
        playSound(soundEffects.coin);
        starship3.redPointsCollected++;
        redPointsTotal++;
        
        // Vérifier l'activation du bouclier
        if (starship3.redPointsCollected >= 100) {
            console.log("🛡️ Activation du bouclier pour le joueur 3 - Points: " + starship3.redPointsCollected);
            
            // CORRECTION: Forcer la désactivation du shield précédent si il existe
            if (starship3.shieldTimeout) {
                clearTimeout(starship3.shieldTimeout);
                starship3.shieldTimeout = null;
            }
            
            activateShield(starship3);
            starship3.redPointsCollected = 0;
            console.log("🛡️ Shield joueur 3 activé, compteur réinitialisé");
        }
        
        return false;
    }
}
}
function checkCollisions() {
    // Ne pas vérifier les collisions uniquement si le jeu est explicitement en pause
    if (gameManager.isPaused) return;

    // Limiter la taille des tableaux pour éviter les problèmes de performance
    if (enemies.length > 40) enemies = enemies.slice(0, 40);
    if (enemyBullets.length > 60) enemyBullets = enemyBullets.slice(0, 60);

    const checkPlayerCollisions = (player, playerNumber) => {
        if (!player || !player.isActive) return;

                // Collisions balles-ennemis
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    let enemyHit = false;

                    for (let j = player.bullets.length - 1; j >= 0; j--) {
                        const bullet = player.bullets[j];
                        if (!bullet || !enemy) continue;

                        if (checkCollision(bullet, enemy)) {
                            playSound(soundEffects.hit);
                            player.bullets.splice(j, 1);
                            enemyHit = true;

// Explosion plus spectaculaire
for (let k = 0; k < 100; k++) {  // Quelques particules d'explosion
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3;
    redPoints.push({
        x: enemy.x + enemy.width/2,
        y: enemy.y + enemy.height/2,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 30 + Math.floor(Math.random() * 20),
        isExplosion: true,  // Identifier comme particule d'explosion
        color: ["fuchsia"][Math.floor(Math.random() * 3)]
    });
}

// Points rouges récoltables (conserver le comportement d'origine)
for (let k = 0; k < 10; k++) {
    redPoints.push({
        x: enemy.x + Math.random() * enemy.width,
        y: enemy.y + Math.random() * enemy.height,
        isCollectible: true  // Identifier comme point récoltable
    });
}

                            handleKill(playerNumber);
                            break;
                        }
                    }

                    if (enemyHit) {
                        enemies.splice(i, 1);
                        continue;
                    }

                    if (checkCollision(player, enemy)) {
                        playSound(soundEffects.hit);
                        if (!player.shield) {
                            player.lives--;
                            updatePlayerStats();
                        }
                        enemies.splice(i, 1);

                        if (player.lives <= 0) {
                            playerDeath(player);
                        }
                    }
                }
// Modification de la section de collision avec les balles ennemies dans la fonction checkCollisions
// Remplacer le bloc existant par celui-ci:

// Collisions avec les balles ennemies
for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const bullet = enemyBullets[i];
    if (checkCollision(player, bullet)) {
        playSound(soundEffects.hit);
        enemyBullets.splice(i, 1);

        if (!player.shield) {
            // Réduire le niveau de power-up avant de perdre une vie
            if (player.powerUpLevel > 0) {
                player.powerUpLevel = Math.max(0, player.powerUpLevel - 1);
                
                // Effet visuel léger pour indiquer la perte du power-up
                for (let k = 0; k < 20; k++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    redPoints.push({
                        x: player.x + player.width/2,
                        y: player.y + player.height/2,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 10 + Math.floor(Math.random() * 5),
                        isExplosion: true,
                        color: "cyan" // Couleur cyan pour indiquer la perte de power-up
                    });
                }
            } else {
                // Si plus de power-up, perdre une vie
                player.lives--;
                killsWithoutDeath = 0;
                updatePlayerStats();
                
                // Si c'est la dernière vie (mort du joueur), explosion massive
                if (player.lives <= 0) {
                    // Grande explosion finale
                    for (let k = 0; k < 1000; k++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 2 + Math.random() * 4;
                        redPoints.push({
                            x: player.x + player.width/2,
                            y: player.y + player.height/2,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 30 + Math.floor(Math.random() * 30),
                            isExplosion: true,
                            color: ["purple", "yellow", "grey"][Math.floor(Math.random() * 4)]
                        });
                    }
                    playerDeath(player);
                } else {
                    // Explosion normale quand touché mais pas encore mort
                    for (let k = 0; k < 100; k++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 1 + Math.random() * 2;
                        redPoints.push({
                            x: player.x + player.width/2,
                            y: player.y + player.height/2,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 15 + Math.floor(Math.random() * 10),
                            isExplosion: true,
                            color: ["grey","yellow"][Math.floor(Math.random() * 3)]
                        });
                    }
                }
            }
        }
    }
}
            };

            checkPlayerCollisions(starship, 1);
            if (isMultiplayer && starship2) checkPlayerCollisions(starship2, 2);
            if (isTriplePlayer && starship3) checkPlayerCollisions(starship3, 3);

            bonusManager.checkAllCollisions();
            if (isMultiplayer) checkPlayerVsPlayerCollisions();
        }

        function playerDeath(player) {
    player.isActive = false;

    let allPlayersDead = !starship.isActive;
    if (isMultiplayer) allPlayersDead = allPlayersDead && !starship2.isActive;
    if (isTriplePlayer) allPlayersDead = allPlayersDead && !starship3.isActive;

    // Message quand un joueur meurt en mode multijoueur
    const playerMessage = document.createElement("div");
    playerMessage.style.position = "absolute";
    playerMessage.style.color = player.player === 1 ? "#04fbac" :
                              player.player === 2 ? "#FF7F50" : "#FFFF50";
    playerMessage.style.fontSize = "24px";
    playerMessage.style.fontWeight = "bold";
    playerMessage.style.padding = "10px";
    playerMessage.style.borderRadius = "5px";
    playerMessage.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    playerMessage.style.left = "50%";
    playerMessage.style.transform = "translateX(-50%)";
    playerMessage.style.zIndex = "100";
    playerMessage.style.top = (30 + (player.player - 1) * 10) + "%";
    playerMessage.textContent = `Joueur ${player.player} T'ES MORT !`;

    document.body.appendChild(playerMessage);

    if (allPlayersDead) {
        // Attendre 1.5 secondes avant d'afficher le Game Over
        // pour laisser le temps de voir l'explosion finale
        setTimeout(() => {
            gameOver();
            document.body.removeChild(playerMessage);
        }, 1500);
    } else {
        setTimeout(() => {
            document.body.removeChild(playerMessage);
        }, 2000);
    }
}
        function gameOver() {
    document.querySelectorAll("[id^='stun-effect-player'], [id^='shield-effect-player']").forEach(e => e.remove());
    Object.values(soundEffects).forEach(sound => {
        sound.pause();
        sound.currentTime = 0;
    });

    const gameOverContainer = document.getElementById("gameOverContainer");
    const gameOverMessage = document.getElementById("gameOverMessage");
    const continueCounter = document.getElementById("continueCounter");

    gameOverContainer.style.display = "block";
    gameManager.isPaused = true;

    // Jouer le son continue.mp3 pendant le compte à rebours
    playSound(soundEffects.continue);

    let countdown = 5;
    continueCounter.textContent = countdown;

    const countInterval = setInterval(() => {
        countdown--;
        continueCounter.textContent = countdown;

        if (countdown <= 0) {
            clearInterval(countInterval);
            continueCounter.style.display = "none";
            gameOverMessage.style.display = "block";
           
            // Arrêter le son continue et jouer le son gameover
            soundEffects.continue.pause();
            soundEffects.continue.currentTime = 0;
            playSound(soundEffects.gameOver);

            setTimeout(() => {
                window.location.href = '/pages/garage.html';
                gameOverContainer.style.display = "none";
                gameOverMessage.style.display = "none";
                continueCounter.style.display = "block";
                gameManager.isPaused = false;

                // Réinitialisation
                enemies = [];
                enemyBullets = [];
                redPoints = [];
                enemiesKilled = 0;
                simultaneousKills = 0;
                killsWithoutDeath = 0;
                coins = 0;

                [starship, starship2, starship3].filter(Boolean).forEach(player => {
                    player.bullets = [];
                    player.powerUpLevel = 0;
                    player.lives = 3;
                    player.isActive = true;
                });

                if (isMultiplayer) {
                    document.getElementById("p1Points").textContent = "0";
                    document.getElementById("p1Kills").textContent = "0";
                    if (starship2) {
                        document.getElementById("p2Points").textContent = "0";
                        document.getElementById("p2Kills").textContent = "0";
                    }
                    if (isTriplePlayer && starship3) {
                        document.getElementById("p3Points").textContent = "0";
                        document.getElementById("p3Kills").textContent = "0";
                    }
                }

                document.getElementById("livesCount").innerText = playerLives;
                document.getElementById("enemiesKilledCount").innerText = enemiesKilled;
                document.getElementById("coinsCount").textContent = coins.toFixed(1);

                starship.x = canvas.width / 2;
                starship.y = canvas.height - 50;
                if (isMultiplayer && starship2) {
                    starship2.x = canvas.width / 2 + 100;
                    starship2.y = canvas.height - 50;
                }
                if (isTriplePlayer && starship3) {
                    starship3.x = canvas.width / 2 - 100;
                    starship3.y = canvas.height - 50;
                }

                if (enemiesKilled < 5) {
                    playSound(soundEffects.humiliation);
                }
            }, 2000);
        }
    }, 1000);
}

        function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
   
    // Repositionner le vaisseau pour qu'il reste dans les limites du canvas
    if (starship) {
        starship.x = Math.min(starship.x, canvas.width - starship.width);
        starship.y = Math.min(starship.y, canvas.height - starship.height);
    }
    if (starship2) {
        starship2.x = Math.min(starship2.x, canvas.width - starship2.width);
        starship2.y = Math.min(starship2.y, canvas.height - starship2.height);
    }
    if (starship3) {
        starship3.x = Math.min(starship3.x, canvas.width - starship3.width);
        starship3.y = Math.min(starship3.y, canvas.height - starship3.height);
    }
}

// CORRECTION 8: Améliorer la fonction update pour gérer les animations de fond
function update(timestamp) {
    try {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Vérifier et mettre à jour l'animation du fond en fonction du stage
        const scrollingBg = document.getElementById("scrollingBackground");
        if (isStage3 && scrollingBg.style.display === "block") {
            // S'assurer que le fond utilise l'animation verticale pour le stage 3
            if (scrollingBg.style.animation !== "scrollBackgroundVertical 60s linear infinite") {
                scrollingBg.style.animation = "scrollBackgroundVertical 60s linear infinite";
            }
        } else if (isStage2 && scrollingBg.style.display === "block") {
            // S'assurer que le fond utilise l'animation horizontale pour le stage 2
            if (scrollingBg.style.animation !== "rotateBackground 60s linear infinite") {
                scrollingBg.style.animation = "rotateBackground 60s linear infinite";
            }
        }

        if (isMultiplayer) {
            updateMultiplayerControls();
        }

        // Mise à jour des particules de bouclier
        updateShieldParticles();
        
        drawStarship();
        drawShieldParticles();
        updateStunEffects();
        updateAndDrawThunder();
        drawBullets();
        drawEnemies();
        drawEnemyBullets();
        drawRedPoints();
        updateAndDrawStars();
        checkSpecialShotAvailability();
updateAndDrawSpecialShot();
updateAndDrawAssistantShips()

        // Mettre à jour et dessiner le mini-boss
        if (miniBossActive) {
            updateMiniBoss();
            drawMiniBoss();
            checkMiniBossCollisions();
        }

        if (bossActive) {
            updateBoss();
            
            if (bossActive && boss && boss.isBoss3) {
    updateBoss3();
}
            drawBoss();
            checkBossCollisions();
        }

        bonusManager.update();
        bonusManager.draw(ctx);

        gameManager.draw(ctx);

        checkCollisions();
        if (isMultiplayer) {
            checkPlayerVsPlayerCollisions();
        }
    } catch (error) {
        console.error("Erreur dans la boucle de jeu:", error);
    }

    const currentTime = Date.now();
    const frameDelta = currentTime - (window.lastFrameTime || currentTime);
    window.lastFrameTime = currentTime;

    if (frameDelta > 100) {
        if (frameDelta > 300) {
            if (enemies.length > 15) enemies = enemies.slice(0, 15);
            if (enemyBullets.length > 20) enemyBullets = enemyBullets.slice(0, 20);
            if (redPoints.length > 50) redPoints = redPoints.slice(0, 50);
        }
    }

    requestAnimationFrame(update);
}

        // Initialisation
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();
// Chargement des ressources
Promise.all([
    ...enemyImgs,
    ...enemyBulletImgs,
    ...powerUpImgs,
    starshipImg,
    bulletImg,
    livesImg,
    bossImg,     // Ajouté
    boss2Img,    // Ajouté
    ...(isMultiplayer ? [starship2Img] : []),
    ...(isTriplePlayer ? [starship3Img] : [])
].filter(Boolean).map(img => new Promise(resolve => {
    if (img.complete) {
        resolve();
    } else {
        img.onload = resolve;
        img.onerror = () => {
            console.error("Erreur de chargement pour:", img.src);
            resolve();
        };
    }
})))
        .then(() => {
            try {
                updatePlayerStats();
                checkGameState();
                requestAnimationFrame(update);

                const intervals = [
                    setInterval(shootBullet, 100),
                    setInterval(generateEnemies, 2000),
                    setInterval(shootEnemyBullets, 1000),
                    setInterval(() => {
                        if (!gameManager.isPaused) {
                            const specialEnemies = enemies.filter(e => e.type === 1).slice(0, 3);
                            specialEnemies.forEach(() => shootEnemyBullets());
                        }
                    }, 500)
                ];

                window.addEventListener("beforeunload", () => {
                    intervals.forEach(clearInterval);
                });

            } catch (error) {
                console.error("Erreur au démarrage du jeu:", error);
            }
        })
        .catch(error => {
            console.error("Erreur lors du chargement des ressources:", error);
        });
    </script>
</body>
</html>