<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Guerre-galactique</title>
    <style>
        /* Styles de base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            touch-action: none; /* Désactive les gestes tactiles par défaut */
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        /* Canvas du jeu */
        #gameCanvas {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: block;
            touch-action: none;
        }

        /* Interface utilisateur */
        .stats {
            position: absolute;
            top: min(20px, 5vh);
            left: min(20px, 5vw);
            font-size: clamp(14px, 4vw, 20px);
            z-index: 10;
        }

        #coinsCount {
            position: absolute;
            top: min(20px, 5vh);
            right: min(20px, 5vw);
            font-size: clamp(14px, 4vw, 20px);
            z-index: 10;
        }

        /* Conteneur vidéo */
        #videoContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #powerUpVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Changé à contain pour meilleure visibilité sur mobile */
        }

        /* Écrans de fin de jeu */
        #gameOverContainer {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.9);
            color: red;
            font-family: Arial, sans-serif;
        }

        #continueCounter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(50px, 20vw, 100px);
            text-align: center;
        }

        #gameOverMessage {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            color: red;
            padding: min(50px, 10vw);
            font-size: clamp(40px, 15vw, 100px);
            border: 5px solid red;
            z-index: 2001;
            text-align: center;
            width: min(90%, 500px);
        }

        .player-stats {
            position: fixed;
            right: min(20px, 5vw);
            top: min(60px, 15vh);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: clamp(12px, 3vw, 16px);
            z-index: 10;
            max-width: 90vw;
        }

        .player-stats-item {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .player1-stats {
            background: rgba(4, 251, 172, 0.2);
        }

        .player2-stats {
            background: rgba(255, 127, 80, 0.2);
        }

        .player3-stats {
            background: rgba(255, 255, 80, 0.2);
        }

        /* Style pour l'indicateur de vie du boss */
        #bossHealthBar {
            position: absolute;
            top: min(50px, 10vh);
            left: 50%;
            transform: translateX(-50%);
            width: min(300px, 80vw);
            height: min(20px, 4vh);
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid red;
            display: none;
            z-index: 10;
        }

        #bossHealthFill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff6600);
            width: 100%;
            transition: width 0.3s;
        }

        @keyframes rotateBackground {
            from { background-position: 0 0; }
            to { background-position: 100% 0; }
        }

        .scrolling-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('/img/back1.png') repeat-x;
            background-size: auto 100%;
            z-index: -1;
            animation: rotateBackground 60s linear infinite;
        }

       /* Animation de bouclier */
@keyframes shieldPulse {
    0% {
        transform: scale(1) rotate(0deg);
        opacity: 0.6;
        box-shadow: 0 0 15px currentColor, inset 0 0 10px currentColor;
    }
    50% {
        transform: scale(1.1) rotate(180deg);
        opacity: 0.8;
        box-shadow: 0 0 25px currentColor, inset 0 0 20px currentColor;
    }
    100% {
        transform: scale(1) rotate(360deg);
        opacity: 0.6;
        box-shadow: 0 0 15px currentColor, inset 0 0 10px currentColor;
    }
}

.shield-effect {
    animation: shieldPulse 4s infinite linear;
    border: 2px solid currentColor;
    border-radius: 50%;
    position: absolute;
    pointer-events: none;
    z-index: 900;
    background: radial-gradient(circle at center, transparent 60%, currentColor 100%);
}

.shield-effect::before, .shield-effect::after {
    content: '';
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    border: 1px solid currentColor;
    border-radius: 50%;
    animation: shieldPulse 3s infinite linear reverse;
    opacity: 0.5;
}

.shield-effect::after {
    top: -5px;
    left: -5px;
    right: -5px;
    bottom: -5px;
    border: 1px dashed currentColor;
    animation-duration: 5s;
    animation-direction: normal;
}

/* Nouveau style pour les particules de bouclier individuelles */
@keyframes particleBlink {
    0%, 100% { opacity: 0.2; }
    50% { opacity: 1; }
}

.shield-particle {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    animation: particleBlink 1s infinite alternate;
}
       

        .touch-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 999;
            display: none;
        }
       
        .player-mode {
            font-size: clamp(14px, 4vw, 20px);
        }

        /* Adaptation pour orientation paysage vs portrait */
        @media (orientation: portrait) {
            .player-stats {
                top: min(120px, 20vh);
                max-width: 80vw;
            }
        }
        #gameCanvas {
    cursor: none;
}
#stageTitle {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    color: #ff0000;
    text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
    text-align: center;
    opacity: 0;
    transition: opacity 2s;
    z-index: 1000;
    pointer-events: none;
    font-weight: bold;
    display: none;
}
    </style>
</head>
<body>
    <!-- Interface utilisateur -->
    <span id="coinsCount">0</span>
    <div class="stats">
        Vies: <span id="livesCount">3</span><br>
        Ennemis tués: <span id="enemiesKilledCount">0</span>
    </div>

    <!-- Fond d'écran défilant -->
    <div id="scrollingBackground" class="scrolling-background" style="display: none;"></div>
   
    <!-- Barre de vie du boss -->
    <div id="bossHealthBar">
        <div id="bossHealthFill"></div>
    </div>

    <div class="player-mode" id="playerModeIndicator" style="position: absolute; top: min(20px, 5vh); left: 50%; transform: translateX(-50%); color: #04fbac; z-index: 10;">Mode 1 joueur</div>
    <div id="playerStats" class="player-stats" style="display: none;">
        <div id="player1Stats" class="player-stats-item player1-stats">
            Player 1: <span id="p1Lives">3</span> vies |
            Points: <span id="p1Points">0</span> |
            Kills: <span id="p1Kills">0</span>
        </div>
        <div id="player2Stats" class="player-stats-item player2-stats">
            Player 2: <span id="p2Lives">3</span> vies |
            Points: <span id="p2Points">0</span> |
            Kills: <span id="p2Kills">0</span>
        </div>
        <div id="player3Stats" class="player-stats-item player3-stats">
            Player 3: <span id="p3Lives">3</span> vies |
            Points: <span id="p3Points">0</span> |
            Kills: <span id="p3Kills">0</span>
        </div>
    </div>
    <div id="stageTitle">STAGE 2: PLANÈTE DÉSOLÉE</div>

    <!-- Indicateur de toucher -->
    <div id="touchIndicator" class="touch-indicator"></div>

    <!-- Canvas du jeu -->
    <canvas id="gameCanvas"></canvas>

    <!-- Conteneur vidéo pour les power-ups -->
    <div id="videoContainer">
        <video id="powerUpVideo" src="video/tirePlasma.mp4" playsinline></video>
    </div>

    <!-- Conteneurs pour le game over -->
    <div id="gameOverContainer">
        <div id="continueCounter"></div>
    </div>
    <div id="gameOverMessage">GAME OVER</div>

    <script>
        // Configuration initiale
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
       

       

        // Récupération des paramètres de difficulté
        const enemySpeedMultiplier = parseFloat(localStorage.getItem('enemySpeed')) || 1;
        const enemyBulletSpeedMultiplier = parseFloat(localStorage.getItem('enemyBulletSpeed')) || 3;
        const powerUpFrequency = parseInt(localStorage.getItem('powerUpFrequency')) || 5;
        const livesFrequency = parseInt(localStorage.getItem('livesFrequency')) || 5;

        // Variables globales
        let gameIsRunning = true;
        let lastFrameTime = 0;
        let deltaTime = 0;
        let fpsCounter = 0;
        let fpsTimer = 0;
        const fpsLimit = 60;
        const frameDuration = 1000 / fpsLimit;
        // Variables pour le stage 2
let isStage2 = false;
let stage2EnemiesKilled = 0;
const boss2Img = new Image();
boss2Img.src = "/img/boss2.jpg";

        // Détection des appareils mobiles
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// Variables tactiles
let touchActive = false;
let lastTouchX = 0;
let lastTouchY = 0;
let touchShootInterval = null;
const touchIndicator = document.getElementById("touchIndicator");

        // Variables de jeu
        let shooting = false;
        let enemies = [];
        let enemyBullets = [];
        let enemiesKilled = 0;
        let playerLives = 3;
        let simultaneousKills = 0;
        let killTimer = null;
        let redPoints = [];
        let coins = 0;
        let killsWithoutDeath = 0;
        let lastKillTime = Date.now();
        let lastEnemyCount = 0;
        let powerUpTimeoutId = null;

        // Boss configuration
        let bossActive = false;
        let boss = null;
        const bossImg = new Image();
        bossImg.src = "/img/boss.jpg";
        let bossHealth = 500; // Augmenté à 500
        let bossRotation = 0;
        let bossShootTimer = 0;
        let bossHitEffect = false;
        let bossHitEffectTimer = 0;
        let backgroundActive = false;
        // Variables pour le mini-boss
let miniBossActive = false;
let miniBoss = null;
const miniBossImg = new Image();
miniBossImg.src = "/img/miniBoss.jpg";
let miniBossHealth = 50;
let miniBossShootTimer = 0;

        // Configuration multijoueur
        const urlParams = new URLSearchParams(window.location.search);
        const playersCount = urlParams.get('players') || '1';
        const isMultiplayer = playersCount !== '1';
        const isTriplePlayer = playersCount === '3';

        // Mise à jour de l'indicateur de mode
        document.getElementById('playerModeIndicator').textContent =
            isTriplePlayer ? 'Mode 3 joueurs' :
            (isMultiplayer ? 'Mode 2 joueurs' : 'Mode 1 joueur');

        // Configuration des vaisseaux
        const starship = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            width: 50,
            height: 50,
            bullets: [],
            powerUpLevel: 0,
            player: 1,
            powerUpTimeoutId: null,
            lives: 3,
            isActive: true,
            stunned: false,
            stunnedTimeout: null,
            redPointsCollected: 0,
            shield: false,
            shieldTimeout: null
        };

        const starship2 = isMultiplayer ? {
            x: canvas.width / 2 + 100,
            y: canvas.height - 50,
            width: 50,
            height: 50,
            bullets: [],
            powerUpLevel: 0,
            player: 2,
            powerUpTimeoutId: null,
            lives: 3,
            isActive: true,
            stunned: false,
            stunnedTimeout: null,
            redPointsCollected: 0,
            shield: false,
            shieldTimeout: null
        } : null;

        const starship3 = isTriplePlayer ? {
            x: canvas.width / 2 - 100,
            y: canvas.height - 50,
            width: 50,
            height: 50,
            bullets: [],
            powerUpLevel: 0,
            player: 3,
            powerUpTimeoutId: null,
            lives: 3,
            isActive: true,
            stunned: false,
            stunnedTimeout: null,
            redPointsCollected: 0,
            shield: false,
            shieldTimeout: null
        } : null;

        // Variables de contrôle
        let keyUp = false, keyDown = false, keyLeft = false, keyRight = false, keySpace = false;
        let keyW = false, keyS = false, keyA = false, keyD = false, keyE = false;
        let shooting2 = false;
        let shooting3 = false;
        let gamepadConnected = false;
        let gamepadIndex = null;
        let shipRotation = 0;
        const maxRotation = 20;
        const rotationSpeed = 0.5;
        let lastShipX = canvas.width/2;

        // Chargement des sons
const soundEffects = {
    shoot: new Audio("/audio/shoot.mp3"),
    hit: new Audio("/audio/hit.mp3"),
    coin: new Audio("/audio/coin.mp3"),
    king: new Audio("/audio/king.mp3"),
    perfect: new Audio("/audio/perfect.mp3"),
    doubleKill: new Audio("/audio/doubleKill.mp3"),
    tripleKill: new Audio("/audio/tripleKill.mp3"),
    humiliation: new Audio("/audio/humiliation.mp3"),
    brutal: new Audio("/audio/brutal.mp3"),
    super: new Audio("/audio/super.mp3"),
    master: new Audio("/audio/master.mp3"),
    awesome: new Audio("/audio/awesome.mp3"),
    bossAppear: new Audio("/audio/king.mp3"),
    bossHit: new Audio("/audio/hit.mp3"),
    bossDeath: new Audio("/audio/awesome.mp3"),
    continue: new Audio("/audio/continue.mp3"),
    gameOver: new Audio("/audio/gameOver.mp3")
};

// Configuration des volumes
const volumes = {
    shoot: 0.3,
    hit: 1.0,
    coin: 0.4,
    king: 0.7,
    perfect: 1.0,
    doubleKill: 0.7,
    tripleKill: 0.5,
    humiliation: 1.0,
    brutal: 1.0,
    super: 1.0,
    master: 1.0,
    awesome: 1.0,
    bossAppear: 1.0,
    bossHit: 0.5,
    bossDeath: 1.0,
    continue: 1.0,
    gameOver: 1.0
};

Object.keys(soundEffects).forEach(key => {
    soundEffects[key].volume = volumes[key] || 1.0;
});

// Configuration des particules de bouclier
const shieldParticles = {
  particleCount: 20,
  particles: [],
  colors: ["#04fbac", "#00ffff", "#0088ff"],
  minSize: 2,
  maxSize: 4,
  minSpeed: 0.02,
  maxSpeed: 0.05
};

// Créer la fonction d'initialisation des particules
function createShieldParticles(player) {
  // Vider le tableau de particules existantes s'il y en a
  shieldParticles.particles = [];
  
  // Créer de nouvelles particules
  for (let i = 0; i < shieldParticles.particleCount; i++) {
    const angle = Math.random() * Math.PI * 2; // Angle aléatoire entre 0 et 2π
    const distance = 30 + Math.random() * 10; // Distance depuis le centre du vaisseau
    
    shieldParticles.particles.push({
      x: 0, // Position relative, sera mise à jour à chaque frame
      y: 0,
      size: shieldParticles.minSize + Math.random() * (shieldParticles.maxSize - shieldParticles.minSize),
      angle,
      distance,
      speed: shieldParticles.minSpeed + Math.random() * (shieldParticles.maxSpeed - shieldParticles.minSpeed),
      color: shieldParticles.colors[Math.floor(Math.random() * shieldParticles.colors.length)],
      player: player.player,
      opacity: 0.5 + Math.random() * 0.5,
      blinking: Math.random() > 0.7 // Certaines particules clignotent
    });
  }
}

// Mettre à jour les particules de bouclier
function updateShieldParticles() {
  if (gameManager.isPaused) return;

  // Pour chaque joueur qui a un bouclier actif
  [starship, starship2, starship3].filter(player => player && player.isActive && player.shield).forEach(player => {
    shieldParticles.particles.filter(p => p.player === player.player).forEach(particle => {
      // Mettre à jour l'angle de la particule
      particle.angle += particle.speed;
      if (particle.angle > Math.PI * 2) particle.angle -= Math.PI * 2;
      
      // Si la particule clignote, faire varier son opacité
      if (particle.blinking) {
        particle.opacity = 0.2 + (Math.sin(Date.now() * 0.01) + 1) * 0.4;
      }
    });
  });
}

// Dessiner les particules de bouclier
function drawShieldParticles() {
  [starship, starship2, starship3].filter(player => player && player.isActive && player.shield).forEach(player => {
    const centerX = player.x + player.width / 2;
    const centerY = player.y + player.height / 2;
    
    shieldParticles.particles.filter(p => p.player === player.player).forEach(particle => {
      ctx.save();
      
      // Calculer la position absolue de la particule
      const x = centerX + Math.cos(particle.angle) * particle.distance;
      const y = centerY + Math.sin(particle.angle) * particle.distance;
      
      // Dessiner la particule
      ctx.globalAlpha = particle.opacity;
      ctx.fillStyle = particle.color;
      
      // Ajouter un effet de lueur
      ctx.shadowBlur = 10;
      ctx.shadowColor = particle.color;
      
      // Dessiner la particule en tant que cercle
      ctx.beginPath();
      ctx.arc(x, y, particle.size, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
    
    // Dessiner l'aura de bouclier
    ctx.save();
    const gradient = ctx.createRadialGradient(
      centerX, centerY, player.width / 2,
      centerX, centerY, player.width / 2 + 15
    );
    gradient.addColorStop(0, 'rgba(4, 251, 172, 0)');
    gradient.addColorStop(0.7, 'rgba(4, 251, 172, 0.1)');
    gradient.addColorStop(1, 'rgba(4, 251, 172, 0.3)');
    
    ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.003) * 0.2;
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, player.width / 2 + 15, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

        // Chargement des images
        const starshipImg = new Image();
        const starship2Img = isMultiplayer ? new Image() : null;
        const starship3Img = isTriplePlayer ? new Image() : null;
        const bulletImg = new Image();
        const backgroundImg = new Image();
        backgroundImg.src = "/img/back1.png";
        const enemyImgs = Array(6).fill().map(() => new Image());
        const enemyBulletImgs = Array(3).fill().map(() => new Image());
        const livesImg = new Image();
        const powerUpImgs = Array(3).fill().map(() => new Image());

        // Configuration des chemins d'images
        starshipImg.src = getSelectedShip();
        if (isMultiplayer && starship2Img) starship2Img.src = getSelectedShipP2();
        if (isTriplePlayer && starship3Img) starship3Img.src = getSelectedShipP3();
        bulletImg.src = "/img/bullets1.jpg";
        enemyImgs.forEach((img, i) => img.src = `/img/enemy${i ? i + 1 : ""}.jpg`);
        enemyBulletImgs.forEach((img, i) => img.src = `/img/bullets${i + 2}.jpg`);
        livesImg.src = "/img/lives.jpg";
        powerUpImgs.forEach((img, i) => img.src = `/img/powerUp${i ? i : ""}.jpg`);

        // Classes
        class GameObject {
            constructor(x, y, speed = 1.5) {
                this.x = x;
                this.y = y;
                this.speed = speed;
                this.width = 30;
                this.height = 30;
                this.direction = {
                    x: (Math.random() * 2 - 1) * speed,
                    y: (Math.random() * 2 - 1) * speed
                };
            }

            moveRandomly(canvas) {
                this.x += this.direction.x;
                this.y += this.direction.y;

                if (this.x <= 0 || this.x >= canvas.width - this.width) {
                    this.direction.x *= -1;
                }
                if (this.y <= 0 || this.y >= canvas.height - this.height) {
                    this.direction.y *= -1;
                }

                if (Math.random() < 0.005) {
                    this.direction.x = (Math.random() * 2 - 1) * this.speed;
                    this.direction.y = (Math.random() * 2 - 1) * this.speed;
                }
            }
        }

        class BonusManager {
            constructor() {
                this.powerUps = [];
                this.lives = [];
            }

            addPowerUp(type) {
                if (this.powerUps.length >= 5) return;

                this.powerUps.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: -50,
                    width: 40,
                    height: 40,
                    speed: 1,
                    type: type !== undefined ? type : Math.floor(Math.random() * 2)
                });
            }

            addLife() {
                if (this.lives.length >= 3) return;

                this.lives.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: -50,
                    width: 40,
                    height: 40,
                    speed: 2
                });
            }

            update() {
                if (gameManager.isPaused) return;

                // Mise à jour des power-ups
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.y += powerUp.speed;
                    powerUp.x += Math.sin(Date.now() * 0.002) * 2;
                    powerUp.x = Math.max(0, Math.min(canvas.width - powerUp.width, powerUp.x));

                    if (powerUp.y >= canvas.height) {
                        this.powerUps.splice(i, 1);
                    }
                }

                // Mise à jour des vies
                for (let i = this.lives.length - 1; i >= 0; i--) {
                    const life = this.lives[i];
                    life.y += life.speed;
                    life.x += Math.sin(Date.now() * 0.001) * 1.5;
                    life.x = Math.max(0, Math.min(canvas.width - life.width, life.x));

                    if (life.y >= canvas.height) {
                        this.lives.splice(i, 1);
                    }
                }
            }

            draw(ctx) {
                // Dessin des power-ups
                this.powerUps.forEach(powerUp => {
                    try {
                        ctx.drawImage(
                            powerUpImgs[powerUp.type],
                            powerUp.x, powerUp.y,
                            powerUp.width, powerUp.height
                        );

                        if (Math.random() > 0.7) {
                            ctx.save();
                            ctx.globalAlpha = 0.3;
                            ctx.fillStyle = "#04fbac";
                            ctx.beginPath();
                            ctx.arc(
                                powerUp.x + powerUp.width/2,
                                powerUp.y + powerUp.height/2,
                                powerUp.width/2 + 5,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            ctx.restore();
                        }
                    } catch (error) {
                        console.error("Erreur lors du dessin d'un power-up:", error);
                    }
                });

                // Dessin des vies
                this.lives.forEach(life => {
                    try {
                        ctx.drawImage(
                            livesImg,
                            life.x, life.y,
                            life.width, life.height
                        );

                        const pulseFactor = Math.sin(Date.now() * 0.005) * 0.2 + 1;

                        ctx.save();
                        ctx.globalAlpha = 0.2;
                        ctx.fillStyle = "red";
                        ctx.beginPath();
                        ctx.arc(
                            life.x + life.width/2,
                            life.y + life.height/2,
                            life.width/2 * pulseFactor,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.restore();
                    } catch (error) {
                        console.error("Erreur lors du dessin d'une vie:", error);
                    }
                });
            }

            checkAllCollisions() {
                this.checkCollisions(
                    starship,
                    type => activatePowerUp(starship, type),
                    () => {
                        starship.lives++;
                        updatePlayerStats();
                        playSound(soundEffects.perfect);
                    }
                );

                if (isMultiplayer && starship2) {
                    this.checkCollisions(
                        starship2,
                        type => activatePowerUp(starship2, type),
                        () => {
                            starship2.lives++;
                            updatePlayerStats();
                            playSound(soundEffects.perfect);
                        }
                    );
                }

                if (isTriplePlayer && starship3) {
                    this.checkCollisions(
                        starship3,
                        type => activatePowerUp(starship3, type),
                        () => {
                            starship3.lives++;
                            updatePlayerStats();
                            playSound(soundEffects.perfect);
                        }
                    );
                }
            }

            checkCollisions(ship, handlePowerUp, handleLife) {
                if (!ship || !ship.isActive) return;

                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    if (checkCollision(ship, powerUp)) {
                        handlePowerUp(powerUp.type);
                        this.powerUps.splice(i, 1);
                    }
                }

                for (let i = this.lives.length - 1; i >= 0; i--) {
                    const life = this.lives[i];
                    if (checkCollision(ship, life)) {
                        handleLife();
                        this.lives.splice(i, 1);
                    }
                }
            }
        }

        class GameManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.isPaused = false;
                this.setupPauseControl();
            }

            setupPauseControl() {
    window.addEventListener("mousedown", (e) => {
        if (e.button === 1) {
            e.preventDefault();
            this.togglePause();
        }
    });

    window.addEventListener("keydown", (e) => {
        if (e.code === "Escape") {
            this.togglePause();
        }
    });
   
    // Double tap pour pause sur mobile
    if (isMobile) {
        let lastTap = 0;
        document.addEventListener('touchend', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 300 && tapLength > 0 && e.touches.length === 0) {
                this.togglePause();
                e.preventDefault();
            }
            lastTap = currentTime;
        });
    }
}

            togglePause() {
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                    soundEffects.shoot.pause();
                } else if (shooting && !starship.stunned) {
                    soundEffects.shoot.play();
                }
            }
            togglePause() {
    this.isPaused = !this.isPaused;
    if (this.isPaused) {
        soundEffects.shoot.pause();
        // Arrêter le tir continu si en pause
        if (touchShootInterval) {
            clearInterval(touchShootInterval);
            touchShootInterval = null;
        }
    } else if (shooting && !starship.stunned) {
        soundEffects.shoot.play();
        // Reprendre le tir si le doigt était sur l'écran
        if (touchActive && !touchShootInterval) {
            touchShootInterval = setInterval(shootBullet, 100);
        }
    }
}
            draw(ctx) {
                if (this.isPaused) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = "white";
                    ctx.font = "48px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText("PAUSE", canvas.width / 2, canvas.height / 2);
                }
            }
        }

        // Création des instances
        const gameManager = new GameManager(canvas);
        const bonusManager = new BonusManager();

        // Événements
        window.addEventListener("gamepadconnected", function(e) {
            console.log("Manette connectée à l'indice %d: %s. %d boutons, %d axes.",
                e.gamepad.index, e.gamepad.id,
                e.gamepad.buttons.length, e.gamepad.axes.length);
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
        });

        window.addEventListener("gamepaddisconnected", function(e) {
            if (gamepadIndex === e.gamepad.index) {
                gamepadConnected = false;
                gamepadIndex = null;
            }
        });

        // Contrôles clavier
        window.addEventListener("keydown", function(e) {
            if (isMultiplayer) {
                switch(e.code) {
                    case "ArrowUp": keyUp = true; break;
                    case "ArrowDown": keyDown = true; break;
                    case "ArrowLeft": keyLeft = true; break;
                    case "ArrowRight": keyRight = true; break;
                    case "Enter":
                        keySpace = true;
                        shooting2 = true;
                        if (!gameManager.isPaused && starship2) {
                            starship2.bullets.push({
                                x: starship2.x + starship2.width / 2 - 2.5,
                                y: starship2.y,
                                width: 5,
                                height: 10,
                                speed: 20,
                                player: 2
                            });
                        }
                        break;
                }
            }

            if (isTriplePlayer) {
                switch(e.code) {
                    case "KeyW": keyW = true; break;
                    case "KeyS": keyS = true; break;
                    case "KeyA": keyA = true; break;
                    case "KeyD": keyD = true; break;
                    case "KeyE":
                        keyE = true;
                        shooting3 = true;
                        if (!gameManager.isPaused && starship3) {
                            starship3.bullets.push({
                                x: starship3.x + starship3.width / 2 - 2.5,
                                y: starship3.y,
                                width: 5,
                                height: 10,
                                speed: 20,
                                player: 3
                            });
                        }
                        break;
                }
            }
        });

        window.addEventListener("keyup", function(e) {
            if (isMultiplayer) {
                switch(e.code) {
                    case "ArrowUp": keyUp = false; break;
                    case "ArrowDown": keyDown = false; break;
                    case "ArrowLeft": keyLeft = false; break;
                    case "ArrowRight": keyRight = false; break;
                    case "Enter":
                        keySpace = false;
                        shooting2 = false;
                        break;
                }
            }

            if (isTriplePlayer) {
                switch(e.code) {
                    case "KeyW": keyW = false; break;
                    case "KeyS": keyS = false; break;
                    case "KeyA": keyA = false; break;
                    case "KeyD": keyD = false; break;
                    case "KeyE":
                        keyE = false;
                        shooting3 = false;
                        break;
                }
            }
        });

        // Contrôles souris
        window.addEventListener("mousemove", (event) => {
            if (!gameManager.isPaused && !starship.stunned) {
                starship.x = Math.max(
                    0,
                    Math.min(
                        canvas.width - starship.width,
                        event.clientX - starship.width / 2
                    )
                );
                starship.y = Math.max(
                    0,
                    Math.min(
                        canvas.height - starship.height,
                        event.clientY - starship.height / 2 + 20
                    )
                );
            }
        });
// Contrôles tactiles
if (isMobile) {
    // Événements tactiles pour le vaisseau principal
    canvas.addEventListener("touchstart", function(e) {
        e.preventDefault();
        if (gameManager.isPaused) return;
       
        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;
       
        // Montrer l'indicateur de toucher
        touchIndicator.style.display = "block";
        touchIndicator.style.left = touchX + "px";
        touchIndicator.style.top = touchY + "px";
       
        // Mettre à jour la position du vaisseau
        updateStarshipPosition(touchX, touchY);
       
        // Commencer à tirer
        touchActive = true;
        shooting = true;
        if (!gameManager.isPaused) {
            soundEffects.shoot.play().catch(() => {});
        }
       
        // Configuration du tir continu
        if (!touchShootInterval) {
            touchShootInterval = setInterval(shootBullet, 100);
        }
    });

    canvas.addEventListener("touchmove", function(e) {
        e.preventDefault();
        if (gameManager.isPaused || !touchActive) return;
       
        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;
       
        // Déplacer l'indicateur de toucher
        touchIndicator.style.left = touchX + "px";
        touchIndicator.style.top = touchY + "px";
       
        // Mettre à jour la position du vaisseau
        updateStarshipPosition(touchX, touchY);
    });

    canvas.addEventListener("touchend", function(e) {
        e.preventDefault();
        touchActive = false;
        shooting = false;
        touchIndicator.style.display = "none";
       
        soundEffects.shoot.pause();
        soundEffects.shoot.currentTime = 0;
       
        // Arrêter le tir continu
        if (touchShootInterval) {
            clearInterval(touchShootInterval);
            touchShootInterval = null;
        }
    });

    canvas.addEventListener("touchcancel", function(e) {
        e.preventDefault();
        touchActive = false;
        shooting = false;
        touchIndicator.style.display = "none";
       
        soundEffects.shoot.pause();
        soundEffects.shoot.currentTime = 0;
       
        // Arrêter le tir continu
        if (touchShootInterval) {
            clearInterval(touchShootInterval);
            touchShootInterval = null;
        }
    });
}
        window.addEventListener("mousedown", (e) => {
            if (e.button === 0) {
                shooting = true;
                if (!gameManager.isPaused) {
                    soundEffects.shoot.play().catch(() => {});
                }
            }
        });

        window.addEventListener("mouseup", (e) => {
            if (e.button === 0) {
                shooting = false;
                soundEffects.shoot.pause();
                soundEffects.shoot.currentTime = 0;
            }
        });

        // Fonctions utilitaires
        function playSound(sound) {
            try {
                sound.currentTime = 0;
                sound.play().catch(error => {
                    console.warn("Impossible de jouer le son:", error);
                });
            } catch (error) {
                console.error("Erreur lors de la lecture du son:", error);
            }
        }
        function updateStarshipPosition(x, y) {
    if (!starship || !starship.isActive || starship.stunned) return;
   
    // Mémoriser la dernière position tactile
    lastTouchX = x;
    lastTouchY = y;
   
    // Assurer une position adéquate du vaisseau
    // On place le vaisseau légèrement au-dessus du doigt pour une meilleure visibilité
    const offsetY = 50; // Décalage vertical pour plus de visibilité
   
    starship.x = Math.max(
        0,
        Math.min(
            canvas.width - starship.width,
            x - starship.width / 2
        )
    );
   
    starship.y = Math.max(
        0,
        Math.min(
            canvas.height - starship.height,
            y - offsetY
        )
    );
}
        function checkCollision(rect1, rect2) {
            if (!rect1 || !rect2 ||
                typeof rect1.x !== 'number' || typeof rect1.y !== 'number' ||
                typeof rect2.x !== 'number' || typeof rect2.y !== 'number') {
                return false;
            }

            const overlapX = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) -
                               Math.max(rect1.x, rect2.x));
            const overlapY = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) -
                               Math.max(rect1.y, rect2.y));

            return overlapX > 0 && overlapY > 0;
        }

        function updatePlayerStats() {
            if (isMultiplayer) {
                document.getElementById("playerStats").style.display = "block";
                document.getElementById("p1Lives").textContent = starship.lives;

                if (starship2) {
                    document.getElementById("p2Lives").textContent = starship2.lives;
                }

                if (isTriplePlayer && starship3) {
                    document.getElementById("p3Lives").textContent = starship3.lives;
                }
            } else {
                document.getElementById("livesCount").textContent = starship.lives;
            }
        }

        function getSelectedShip() {
    const key = isMultiplayer ? 'vaisseauChoisiP1' : 'vaisseauChoisi';
    const vaisseauChoisi = localStorage.getItem(key);

            const vaisseauImages = {
                'Intercepteur': 'starship6.jpg',
                'Croiseur': 'starship1.jpg',
                'Destroyer': 'starship2.jpg',
                'Chasseur': 'starship3.jpg',
                'Éclaireur': 'starship4.jpg',
                'Bombardier': 'starship5.jpg',
                'aéronef': 'starship7.jpg'
            };

            if (vaisseauChoisi && vaisseauImages[vaisseauChoisi]) {
                return `/img/${vaisseauImages[vaisseauChoisi]}`;
            }

            return "/img/starship7.jpg";
        }

        function getSelectedShipP2() {
            const vaisseauChoisi = localStorage.getItem('vaisseauChoisiP2');

            const vaisseauImages = {
                'Intercepteur': 'starship6.jpg',
                'Croiseur': 'starship1.jpg',
                'Destroyer': 'starship2.jpg',
                'Chasseur': 'starship3.jpg',
                'Éclaireur': 'starship4.jpg',
                'Bombardier': 'starship5.jpg',
                'aéronef': 'starship7.jpg'
            };

            if (vaisseauChoisi && vaisseauImages[vaisseauChoisi]) {
                return `/img/${vaisseauImages[vaisseauChoisi]}`;
            }

            return "/img/starship6.jpg";
        }

        function getSelectedShipP3() {
            const vaisseauChoisi = localStorage.getItem('vaisseauChoisiP3');

            const vaisseauImages = {
                'Intercepteur': 'starship6.jpg',
                'Croiseur': 'starship1.jpg',
                'Destroyer': 'starship2.jpg',
                'Chasseur': 'starship3.jpg',
                'Éclaireur': 'starship4.jpg',
                'Bombardier': 'starship5.jpg',
                'aéronef': 'starship7.jpg'
            };

            if (vaisseauChoisi && vaisseauImages[vaisseauChoisi]) {
                return `/img/${vaisseauImages[vaisseauChoisi]}`;
            }

            return "/img/starship5.jpg";
        }

        function checkGameState() {
            if (!gameIsRunning) return;

            const currentTime = Date.now();
            const timeSinceLastKill = currentTime - lastKillTime;

            if (enemies.length > 0 && timeSinceLastKill > 10000 && enemies.length === lastEnemyCount) {
                enemies = enemies.slice(0, Math.max(5, Math.floor(enemies.length / 2)));
                lastKillTime = currentTime;
            }

            if (enemies.length > 40) {
                enemies = enemies.slice(0, 40);
            }
            if (enemyBullets.length > 60) {
                enemyBullets = enemyBullets.slice(0, 60);
            }
            if (redPoints.length > 100) {
                redPoints = redPoints.slice(0, 100);
            }

            lastEnemyCount = enemies.length;
            setTimeout(checkGameState, 5000);
        }

        function updateMultiplayerControls() {
            if (gameManager.isPaused) return;

            if (isMultiplayer && starship2 && !starship2.stunned) {
                if (gamepadConnected) {
                    try {
                        const gamepad = navigator.getGamepads()[gamepadIndex];
                        if (gamepad) {
                            const moveSpeed = 15; // Augmentation de la vitesse
                            const axisX = gamepad.axes[0];
                            const axisY = gamepad.axes[1];

                            if (Math.abs(axisX) > 0.1) {
                                starship2.x += axisX * moveSpeed;
                            }
                            if (Math.abs(axisY) > 0.1) {
                                starship2.y += axisY * moveSpeed;
                            }

                            if (gamepad.buttons[0].pressed && !shooting2) {
                                shooting2 = true;
                                starship2.bullets.push({
                                    x: starship2.x + starship2.width / 2 - 2.5,
                                    y: starship2.y,
                                    width: 5,
                                    height: 10,
                                    speed: 20,
                                    player: 2
                                });
                            } else if (!gamepad.buttons[0].pressed) {
                                shooting2 = false;
                            }
                        }
                    } catch (error) {
                        console.error("Erreur manette:", error);
                    }
                }

                const moveSpeed = 15;
                if (keyUp) starship2.y -= moveSpeed;
                if (keyDown) starship2.y += moveSpeed;
                if (keyLeft) starship2.x -= moveSpeed;
                if (keyRight) starship2.x += moveSpeed;

                starship2.x = Math.max(0, Math.min(canvas.width - starship2.width, starship2.x));
                starship2.y = Math.max(0, Math.min(canvas.height - starship2.height, starship2.y));
            }

            if (isTriplePlayer && starship3 && !starship3.stunned) {
                const moveSpeed = 15;
                if (keyW) starship3.y -= moveSpeed;
                if (keyS) starship3.y += moveSpeed;
                if (keyA) starship3.x -= moveSpeed;
                if (keyD) starship3.x += moveSpeed;

                starship3.x = Math.max(0, Math.min(canvas.width - starship3.width, starship3.x));
                starship3.y = Math.max(0, Math.min(canvas.height - starship3.height, starship3.y));
            }
        }

        function handleKill(playerNumber) {
    lastKillTime = Date.now();
    simultaneousKills++;
    enemiesKilled++;
    killsWithoutDeath++;
    document.getElementById("enemiesKilledCount").innerText = enemiesKilled;
   
    // Compteur différent selon le stage
  // Compteur différent selon le stage
if (!isStage2) {
    // Stage 1
    if (enemiesKilled === 200 && !bossActive) {
        createBoss();
    }
    // Ajouter cette condition pour faire apparaître le mini-boss
    else if (enemiesKilled % 50 === 0 && !miniBossActive && !bossActive) {
        createMiniBoss();
    }
} else {
    // Stage 2
    stage2EnemiesKilled++;
    if (stage2EnemiesKilled === 200 && !bossActive) {
        createBoss2();
    }
    // Ajouter aussi pour le stage 2
    else if (stage2EnemiesKilled % 50 === 0 && !miniBossActive && !bossActive) {
        createMiniBoss();
    }
}
            if (isMultiplayer) {
                switch (playerNumber) {
                    case 1:
                        const p1Kills = parseInt(document.getElementById("p1Kills").textContent) + 1;
                        document.getElementById("p1Kills").textContent = p1Kills;
                        const p1Points = parseInt(document.getElementById("p1Points").textContent) + 10;
                        document.getElementById("p1Points").textContent = p1Points;
                        break;
                    case 2:
                        const p2Kills = parseInt(document.getElementById("p2Kills").textContent) + 1;
                        document.getElementById("p2Kills").textContent = p2Kills;
                        const p2Points = parseInt(document.getElementById("p2Points").textContent) + 10;
                        document.getElementById("p2Points").textContent = p2Points;
                        break;
                    case 3:
                        const p3Kills = parseInt(document.getElementById("p3Kills").textContent) + 1;
                        document.getElementById("p3Kills").textContent = p3Kills;
                        const p3Points = parseInt(document.getElementById("p3Points").textContent) + 10;
                        document.getElementById("p3Points").textContent = p3Points;
                        break;
                }
            }

            if (killsWithoutDeath === 20) {
                playSound(soundEffects.brutal);
            } else if (killsWithoutDeath === 30) {
                playSound(soundEffects.super);
            } else if (killsWithoutDeath === 40) {
                playSound(soundEffects.master);
            } else if (killsWithoutDeath === 60) {
                playSound(soundEffects.awesome);
            }

            if (enemiesKilled % 30 === 0) {
                bonusManager.addPowerUp(2);
                playSound(soundEffects.king);
            } else if (enemiesKilled % powerUpFrequency === 0) {
                if (Math.random() < 0.5) {
                    bonusManager.addPowerUp();
                } else {
                    bonusManager.addLife();
                }
            }

            clearTimeout(killTimer);
            killTimer = setTimeout(() => {
                if (simultaneousKills === 2) {
                    playSound(soundEffects.doubleKill);
                } else if (simultaneousKills >= 3) {
                    playSound(soundEffects.tripleKill);
                }
                simultaneousKills = 0;
            }, 200);
        }
        function createBoss2() {
    console.log("Création du boss 2");
    if (bossActive) return;
   
    bossActive = true;
    bossHealth = 1000; // Plus de vie pour boss2
   
    document.getElementById("bossHealthBar").style.display = "block";
    document.getElementById("bossHealthFill").style.width = "100%";
   
    boss = {
        x: canvas.width / 2 - 150, // Ajusté pour la taille 2x
        y: 50,
        width: 150,
        height: 150,
        vx: 0.5, // Déplacement plus lent
        vy: 0.5, // Déplacement plus lent
        rotation: 0, // Ne sera pas utilisé pour boss2
        movePattern: 0,
        moveTimer: 0,
        lastMoveChange: Date.now(),
        isBoss2: true
    };
   
    playSound(soundEffects.bossAppear);
    enemies = [];
   
    // Afficher un message pour le boss 2
    const stageTitle = document.getElementById("stageTitle");
    stageTitle.textContent = "BOSS FINAL !";
    stageTitle.style.display = "block";
   
    // Animation de fade-in
    setTimeout(() => {
        stageTitle.style.opacity = "1";
       
        // Animation de fade-out après 2 secondes
        setTimeout(() => {
            stageTitle.style.opacity = "0";
           
            // Masquer l'élément après la transition
            setTimeout(() => {
                stageTitle.style.display = "none";
            }, 2000);
        }, 2000);
    }, 100);
}

function activatePowerUp(ship, powerUpType) {
    if (powerUpType === 2) {
        try {
            gameManager.isPaused = true;
            videoContainer.style.display = "block";
            powerUpVideo.currentTime = 0;

            const playPromise = powerUpVideo.play();
            if (playPromise) {
                playPromise.catch(error => {
                    console.error("Erreur vidéo:", error);
                    endPowerUpVideo();
                });
            }

            powerUpVideo.onended = endPowerUpVideo;
        } catch (error) {
            console.error("Erreur powerup:", error);
            endPowerUpVideo();
        }
    } else {
        if (ship.powerUpTimeoutId) {
            clearTimeout(ship.powerUpTimeoutId);
            ship.powerUpTimeoutId = null;
        }

        // Incrémenter le niveau de powerUp, mais plafonner à 3
        ship.powerUpLevel = Math.min(3, ship.powerUpLevel + 1);

        ship.powerUpTimeoutId = setTimeout(() => {
            ship.powerUpLevel = Math.max(0, ship.powerUpLevel - 1); // Diminuer d'un niveau à l'expiration
            ship.powerUpTimeoutId = null;
        }, 6000);
    }
}

        function endPowerUpVideo() {
            videoContainer.style.display = "none";
            gameManager.isPaused = false;
            enemies = [];
            enemyBullets = [];

            starship.powerUpLevel = 3;
            if (isMultiplayer && starship2) starship2.powerUpLevel = 3;
            if (isTriplePlayer && starship3) starship3.powerUpLevel = 3;

            if (powerUpTimeoutId) {
                clearTimeout(powerUpTimeoutId);
            }

            powerUpTimeoutId = setTimeout(() => {
                starship.powerUpLevel = 0;
                if (isMultiplayer && starship2) starship2.powerUpLevel = 0;
                if (isTriplePlayer && starship3) starship3.powerUpLevel = 0;
                powerUpTimeoutId = null;
            }, 6000);
        }

        function stunPlayer(player, duration = 2000) {
            if (!player || !player.isActive) return;
           
            player.stunned = true;
           
            document.querySelectorAll("#stun-effect-player" + player.player).forEach(e => e.remove());
           
            const stunEffect = document.createElement("div");
            stunEffect.style.position = "absolute";
            stunEffect.style.left = player.x + "px";
            stunEffect.style.top = player.y + "px";
            stunEffect.style.width = player.width + "px";
            stunEffect.style.height = player.height + "px";
            stunEffect.style.border = "2px dashed yellow";
            stunEffect.style.borderRadius = "50%";
            stunEffect.style.boxShadow = "0 0 10px yellow";
            stunEffect.style.animation = "pulse 0.5s infinite alternate";
            stunEffect.style.zIndex = "5";
            stunEffect.id = "stun-effect-player" + player.player;
           
            document.body.appendChild(stunEffect);
           
            if (player.stunnedTimeout) {
                clearTimeout(player.stunnedTimeout);
            }
           
            player.stunnedTimeout = setTimeout(() => {
                player.stunned = false;
                document.querySelectorAll("#stun-effect-player" + player.player).forEach(e => e.remove());
            }, duration);
        }

        function activateShield(player, duration = 10000) {
  // Du code existant concernant l'activation du bouclier
  player.shield = true;
  
  // Probablement du code qui crée un élément pour l'effet visuel
  // ...
  
  // Du code qui définit un timeout pour désactiver le bouclier
  player.shieldTimeout = setTimeout(() => {
    player.shield = false;
    // Plus de code ici...
  }, duration);
}
        function checkPlayerVsPlayerCollisions() {
            if (!isMultiplayer) return;

            const players = [starship];
            if (starship2) players.push(starship2);
            if (starship3) players.push(starship3);

            for (let i = 0; i < players.length; i++) {
                for (let j = i + 1; j < players.length; j++) {
                    const player1 = players[i];
                    const player2 = players[j];

                    if (!player1.isActive || !player2.isActive) continue;

                    player1.bullets.forEach((bullet, index) => {
                        if (checkCollision(bullet, player2) && !player2.shield) {
                            player1.bullets.splice(index, 1);
                            stunPlayer(player2);
                            playSound(soundEffects.hit);
                        }
                    });

                    player2.bullets.forEach((bullet, index) => {
                        if (checkCollision(bullet, player1) && !player1.shield) {
                            player2.bullets.splice(index, 1);
                            stunPlayer(player1);
                            playSound(soundEffects.hit);
                        }
                    });
                }
            }
        }

        function updateStunEffects() {
            [starship, starship2, starship3].filter(Boolean).forEach(player => {
                if (player.stunned) {
                    const effect = document.getElementById("stun-effect-player" + player.player);
                    if (effect) {
                        effect.style.left = player.x + "px";
                        effect.style.top = player.y + "px";
                    }
                }
               
                if (player.shield) {
                    const shield = document.getElementById("shield-effect-player" + player.player);
                    if (shield) {
                        shield.style.left = (player.x - 10) + "px";
                        shield.style.top = (player.y - 10) + "px";
                    }
                }
            });
        }

        // Fonctions pour le boss
        function createBoss() {
            if (bossActive) return;
           
            bossActive = true;
            bossHealth = 500; // Augmentation de la résistance à 500
           
            document.getElementById("bossHealthBar").style.display = "block";
            document.getElementById("bossHealthFill").style.width = "100%";
           
            boss = {
                x: canvas.width / 2 - 75,
                y: 50,
                width: 150,
                height: 150,
                vx: 1, // Augmentation de la vitesse
                vy: 1.5,
                rotation: 0,
                movePattern: 0,
                moveTimer: 0,
                lastMoveChange: Date.now()
            };
           
            playSound(soundEffects.bossAppear);
            enemies = [];
            ctx.globalAlpha = 0.7;
       

   
   
}
        function updateBoss() {
            if (!bossActive || !boss || gameManager.isPaused) return;
           
            // Rotation continue
            boss.rotation += 2;
            if (boss.rotation >= 360) boss.rotation = 0;
           
            // Mouvement dynamique
            const currentTime = Date.now();
            if (currentTime - boss.lastMoveChange > 3000) {
                boss.movePattern = Math.floor(Math.random() * 4);
                boss.lastMoveChange = currentTime;
            }
           
            switch(boss.movePattern) {
                case 0: // Mouvement circulaire
                    boss.moveTimer += 0.02;
                    boss.x = canvas.width/2 + Math.cos(boss.moveTimer) * 200;
                    boss.y = canvas.height/4 + Math.sin(boss.moveTimer) * 100;
                    break;
                case 1: // Zigzag
                    boss.x += boss.vx;
                    if (boss.x <= 0 || boss.x + boss.width >= canvas.width) {
                        boss.vx *= -1;
                        boss.y += 50;
                        if (boss.y > canvas.height/2) boss.y = 50;
                    }
                    break;
                case 2: // Mouvement en 8
                    boss.moveTimer += 0.02;
                    boss.x = canvas.width/2 + Math.cos(boss.moveTimer) * 200;
                    boss.y = canvas.height/4 + Math.sin(boss.moveTimer * 2) * 100;
                    break;
                case 3: // Dash aléatoire
                    if (Math.random() < 0.02) {
                        boss.vx = (Math.random() - 0.5) * 8;
                        boss.vy = (Math.random() - 0.5) * 6;
                    }
                    boss.x += boss.vx;
                    boss.y += boss.vy;
                    break;
            }
           
            // Maintenir le boss dans les limites
            boss.x = Math.max(0, Math.min(canvas.width - boss.width, boss.x));
            boss.y = Math.max(0, Math.min(canvas.height/2 - boss.height, boss.y));
           
            // Tirs plus fréquents
            bossShootTimer++;
            if (bossShootTimer >= 30) { // Réduit à 30 frames (deux fois plus rapide)
                shootBossBullets();
                bossShootTimer = 0;
            }
        }

        function drawBoss() {
    if (!bossActive || !boss) return;
   
    ctx.save();
   
    // Augmenter l'opacité globale pour les boss (plus foncés)
    ctx.globalAlpha = boss.isBoss2 ? 1 : 1;  // Pleine opacité
   
   
   
    // Rotation du boss seulement pour le premier boss
    ctx.translate(boss.x + boss.width/2, boss.y + boss.height/2);
    if (!boss.isBoss2) {
        ctx.rotate(boss.rotation * Math.PI / 180);
    }
   
    // Dessin du boss (boss 1 ou boss 2)
    const bossImage = boss.isBoss2 ? boss2Img : bossImg;
   
    if (bossImage.complete) {
        // Boss2 deux fois plus grand
        if (boss.isBoss2) {
            ctx.drawImage(bossImage, -boss.width, -boss.height, boss.width * 2, boss.height * 2);
        } else {
            ctx.drawImage(bossImage, -boss.width/2, -boss.height/2, boss.width, boss.height);
        }
    } else {
        // Image de secours si l'image du boss n'est pas chargée
        ctx.fillStyle = boss.isBoss2 ? "purple" : "red";
        if (boss.isBoss2) {
            ctx.fillRect(-boss.width, -boss.height, boss.width * 2, boss.height * 2);
        } else {
            ctx.fillRect(-boss.width/2, -boss.height/2, boss.width, boss.height);
        }
    }
   
    ctx.restore();
    ctx.globalAlpha = 1.0; // Réinitialiser explicitement l'opacité globale
}

        function shootBossBullets() {
    if (!bossActive || !boss) return;
   
    const isBoss2 = boss.isBoss2 || false;
    const bulletSpeed = isBoss2 ? 1.5 : 1; // Boss 2 tire 50% plus vite
   
    // Tirer dans 16 directions
    for (let i = 0; i < 16; i++) {
        const angle = (i * 22.5) * Math.PI / 180; // 360/16 = 22.5 degrés
        const speed = bulletSpeed;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
       
        enemyBullets.push({
            x: boss.x + boss.width/2,
            y: boss.y + boss.height/2,
            width: 8,
            height: 8,
            speed: 0,
            vx: vx,
            vy: vy,
            type: isBoss2 ? 0 : 2 // Type de balle différent pour le boss 2
        });
    }
   
    // Ajouter des tirs verticaux supplémentaires
    // Tirs vers le bas de façon très explicite
    enemyBullets.push({
        x: boss.x + boss.width/2,
        y: boss.y + boss.height/2,
        width: 8,
        height: 8,
        speed: 5 * (isBoss2 ? 1.5 : 1),
        vx: 0,
        vy: 5 * (isBoss2 ? 1.5 : 1),
        type: isBoss2 ? 0 : 2
    });
   
    // Tirs vers le haut de façon très explicite
    enemyBullets.push({
        x: boss.x + boss.width/2,
        y: boss.y + boss.height/2,
        width: 8,
        height: 8,
        speed: 0,
        vx: 0,
        vy: -5 * (isBoss2 ? 1.5 : 1),
        type: isBoss2 ? 0 : 2
    });
   
    playSound(soundEffects.shoot);
}

function checkBossCollisions() {
    if (!bossActive || !boss) return;
   
    // Vérifier les collisions avec les balles des joueurs
    const checkPlayerBullets = (player) => {
        if (!player || !player.isActive) return;
       
        for (let i = player.bullets.length - 1; i >= 0; i--) {
            const bullet = player.bullets[i];
           
            // Rectangle de collision pour le boss ajusté selon le type
            const bossRect = {
                x: boss.isBoss2 ? boss.x - boss.width/2 : boss.x,
                y: boss.isBoss2 ? boss.y - boss.height/2 : boss.y,
                width: boss.isBoss2 ? boss.width * 2 : boss.width,
                height: boss.isBoss2 ? boss.height * 2 : boss.height
            };
           
            if (checkCollision(bullet, bossRect)) {
                // Supprimer la balle
                player.bullets.splice(i, 1);
               
                // Effet de hit
                bossHitEffect = true;
                bossHitEffectTimer = 0;
               
                // Diminuer la vie du boss
                bossHealth--;
               
                // Mettre à jour la barre de vie
                document.getElementById("bossHealthFill").style.width = (bossHealth / (boss.isBoss2 ? 1000 : 500) * 100) + "%";
               
                playSound(soundEffects.bossHit);
               
                // Vérifier si le boss est détruit
                if (bossHealth <= 0) {
                    defeatBoss();
                }
            }
        }
    };
   
    checkPlayerBullets(starship);
    if (isMultiplayer && starship2) checkPlayerBullets(starship2);
    if (isTriplePlayer && starship3) checkPlayerBullets(starship3);
   
    // Vérifier les collisions entre le boss et les joueurs
    const checkPlayerCollision = (player) => {
        if (!player || !player.isActive) return;
       
        // Rectangle de collision pour le boss
        const bossRect = {
            x: boss.isBoss2 ? boss.x - boss.width/2 : boss.x,
            y: boss.isBoss2 ? boss.y - boss.height/2 : boss.y,
            width: boss.isBoss2 ? boss.width * 2 : boss.width,
            height: boss.isBoss2 ? boss.height * 2 : boss.height
        };
       
        if (checkCollision(player, bossRect)) {
            if (!player.shield) {
                player.lives--;
                updatePlayerStats();
               
                if (player.lives <= 0) {
                    playerDeath(player);
                }
            }
        }
    };
   
    checkPlayerCollision(starship);
    if (isMultiplayer && starship2) checkPlayerCollision(starship2);
    if (isTriplePlayer && starship3) checkPlayerCollision(starship3);
}

        function defeatBoss() {
    // Jouer un son
    playSound(soundEffects.bossDeath);
   
    // Créer un effet d'explosion
    for (let i = 0; i < 100; i++) {
        redPoints.push({
            x: boss.x + Math.random() * boss.width,
            y: boss.y + Math.random() * boss.height
        });
    }
   
    // Désactiver le boss
    bossActive = false;
    boss = null;
   
    // Cacher la barre de vie
    document.getElementById("bossHealthBar").style.display = "none";
   
    // Réinitialiser l'opacité
    ctx.globalAlpha = 1.0;
   
    // Activer le fond d'écran défilant avec un filtre pour améliorer la visibilité
    backgroundActive = true;
    const scrollingBg = document.getElementById("scrollingBackground");
    scrollingBg.style.display = "block";
    scrollingBg.style.filter = "brightness(0.7) contrast(1.2)"; // Assombrir le fond pour mieux voir
   
    // Passer au stage 2
    isStage2 = true;
    stage2EnemiesKilled = 0;

    // Donner un bonus de points
    enemiesKilled += 10;
    document.getElementById("enemiesKilledCount").innerText = enemiesKilled;
   
    // Bonus pour tous les joueurs actifs
    if (isMultiplayer) {
        const p1Points = parseInt(document.getElementById("p1Points").textContent) + 100;
        document.getElementById("p1Points").textContent = p1Points;
       
        if (starship2 && starship2.isActive) {
            const p2Points = parseInt(document.getElementById("p2Points").textContent) + 100;
            document.getElementById("p2Points").textContent = p2Points;
        }
       
        if (isTriplePlayer && starship3 && starship3.isActive) {
            const p3Points = parseInt(document.getElementById("p3Points").textContent) + 100;
            document.getElementById("p3Points").textContent = p3Points;
        }
    }
   
    // Remplacer les images d'ennemis par les nouvelles
    enemyImgs.forEach((img, i) => {
        img.src = `/img/enemy${i + 7}.jpg`; // Utiliser enemy7 à enemy14
    });
   
    // Afficher le titre de stage
    const stageTitle = document.getElementById("stageTitle");
    stageTitle.style.display = "block";
   
    // Animation de fade-in
    setTimeout(() => {
        stageTitle.style.opacity = "1";
       
        // Animation de fade-out après 3 secondes
        setTimeout(() => {
            stageTitle.style.opacity = "0";
           
            // Masquer l'élément après la transition
            setTimeout(() => {
                stageTitle.style.display = "none";
            }, 2000);
        }, 3000);
    }, 100);
   
    // Ajouter quelques power-ups
    bonusManager.addPowerUp(2);
    bonusManager.addLife();
}
// Fonction pour créer le mini-boss
function createMiniBoss() {
    if (miniBossActive) return;
   
    miniBossActive = true;
    miniBossHealth = 50;
   
    miniBoss = {
        x: canvas.width / 2 - 50,
        y: 80,
        width: 100,
        height: 100,
        vx: 0.5, // Mouvement très lent
        vy: 0.3,
        lastShootTime: Date.now()
    };
   
    // Jouer un son d'alerte pour l'apparition du mini-boss
    playSound(soundEffects.king);
}

// Fonction pour mettre à jour le mini-boss
function updateMiniBoss() {
    if (!miniBossActive || !miniBoss || gameManager.isPaused) return;
   
    // Mouvement lent
    miniBoss.x += miniBoss.vx;
    miniBoss.y += miniBoss.vy;
   
    // Rebondir aux bords
    if (miniBoss.x <= 0 || miniBoss.x + miniBoss.width >= canvas.width) {
        miniBoss.vx *= -1;
    }
    if (miniBoss.y <= 0 || miniBoss.y + miniBoss.height >= canvas.height / 2) {
        miniBoss.vy *= -1;
    }
   
    // Tir toutes les 3 secondes
    const currentTime = Date.now();
    if (currentTime - miniBoss.lastShootTime > 3000) {
        shootMiniBossBullets();
        miniBoss.lastShootTime = currentTime;
    }
}

// Fonction pour dessiner le mini-boss
function drawMiniBoss() {
    if (!miniBossActive || !miniBoss) return;
   
    ctx.save();
    
    // Dessiner le mini-boss
    if (miniBossImg.complete) {
        ctx.drawImage(miniBossImg, miniBoss.x, miniBoss.y, miniBoss.width, miniBoss.height);
    } else {
        // Image de secours si l'image n'est pas chargée
        ctx.fillStyle = "orange";
        ctx.fillRect(miniBoss.x, miniBoss.y, miniBoss.width, miniBoss.height);
    }
    
    // Afficher la santé du mini-boss
    ctx.fillStyle = "white";
    ctx.font = "14px Arial";
    ctx.fillText(miniBossHealth + "/50", miniBoss.x + miniBoss.width/2 - 20, miniBoss.y - 10);
    
    ctx.restore();
}

// Fonction pour les tirs du mini-boss
function shootMiniBossBullets() {
    if (!miniBossActive || !miniBoss) return;
    
    // Créer une rangée de 5 lasers rouges
    for (let i = 0; i < 5; i++) {
        enemyBullets.push({
            x: miniBoss.x + (miniBoss.width / 5) * i,
            y: miniBoss.y + miniBoss.height,
            width: 5, // Largeur 5px
            height: 20, // Longueur 20px
            speed: 3, // Vitesse des lasers
            color: "red", // Couleur rouge
            isMiniBossBullet: true // Pour l'identifier
        });
    }
    
    // Ajouter une boule rouge qui suit les lasers
    setTimeout(function() {
        // Créer une boule rouge au centre du mini-boss
        enemyBullets.push({
            x: miniBoss.x + (miniBoss.width / 2) - 5, // Centré (10px de diamètre)
            y: miniBoss.y + miniBoss.height,
            width: 30, // Diamètre 10px
            height: 10, // Forme circulaire
            speed: 2, // Un peu plus lent que les lasers
            color: "red", // Couleur rouge
            isMiniBossBullet: true, // Pour l'identifier
            isRedBall: true // Pour identifier spécifiquement la boule
        });
    }, 500); // Délai de 500ms après les lasers
    
    playSound(soundEffects.shoot);
}
// Fonction pour vérifier les collisions avec le mini-boss
function checkMiniBossCollisions() {
    if (!miniBossActive || !miniBoss) return;
   
    // Vérifier les collisions avec les balles des joueurs
    [starship, starship2, starship3].filter(Boolean).forEach(player => {
        if (!player.isActive) return;
        
        for (let i = player.bullets.length - 1; i >= 0; i--) {
            const bullet = player.bullets[i];
            
            if (checkCollision(bullet, miniBoss)) {
                // Supprimer la balle
                player.bullets.splice(i, 1);
                
                // Réduire la santé du mini-boss
                miniBossHealth--;
                
                // Son de coup
                playSound(soundEffects.hit);
                
                // Vérifier si le mini-boss est détruit
                if (miniBossHealth <= 0) {
                    defeatMiniBoss();
                }
            }
        }
        
        // Vérifier si le joueur touche le mini-boss
        if (checkCollision(player, miniBoss)) {
            if (!player.shield) {
                player.lives--;
                updatePlayerStats();
                
                if (player.lives <= 0) {
                    playerDeath(player);
                }
            }
        }
    });
}

// Fonction pour la défaite du mini-boss
function defeatMiniBoss() {
    // Jouer un son
    playSound(soundEffects.perfect);
   
    // Créer un effet d'explosion
    for (let i = 0; i < 50; i++) {
        redPoints.push({
            x: miniBoss.x + Math.random() * miniBoss.width,
            y: miniBoss.y + Math.random() * miniBoss.height
        });
    }
   
    // Désactiver le mini-boss
    miniBossActive = false;
    miniBoss = null;
   
    // Bonus points
    coins += 10;
    document.getElementById("coinsCount").textContent = coins.toFixed(1);
    
    // Donner un power-up
    bonusManager.addPowerUp();
    bonusManager.addLife();
}
function shootBullet() {
    if (gameManager.isPaused) return;

    [
        { ship: starship, isShooting: shooting },
        { ship: starship2, isShooting: shooting2 },
        { ship: starship3, isShooting: shooting3 }
    ].filter(({ ship }) => ship && ship.isActive).forEach(({ ship, isShooting }) => {
        if (!isShooting) return;

        // Cas de base - niveau 0 (pas de powerUp)
        if (ship.powerUpLevel === 0) {
            ship.bullets.push({
                x: ship.x + ship.width / 2 - 2, // Centré (4px de diamètre)
                y: ship.y,
                width: 4, // Diamètre 4px
                height: 4, // Pour garder un cercle
                speed: 20,
                player: ship.player
            });
        } 
        // Premier powerUp - 3 bullets en ligne horizontale
        else if (ship.powerUpLevel === 1) {
            [-15, -2.5, 10].forEach(xOffset => {
                ship.bullets.push({
                    x: ship.x + ship.width / 2 + xOffset,
                    y: ship.y,
                    width: 4, // Diamètre 4px
                    height: 4, // Pour garder un cercle
                    speed: 10,
                    player: ship.player
                });
            });
        }
        // Deuxième powerUp - 3 bullets de base + 4 bullets décalées verticalement
        else if (ship.powerUpLevel === 2) {
            // 3 bullets de base (comme niveau 1)
            [-15, -2.5, 10].forEach(xOffset => {
                ship.bullets.push({
                    x: ship.x + ship.width / 2 + xOffset,
                    y: ship.y,
                    width: 4,
                    height: 4,
                    speed: 10,
                    player: ship.player
                });
            });
            
            // 4 bullets supplémentaires décalées verticalement
            [-20, -10, 5, 15].forEach(xOffset => {
                ship.bullets.push({
                    x: ship.x + ship.width / 2 + xOffset,
                    y: ship.y - 4, // Décalage vertical de 4px vers le haut
                    width: 4,
                    height: 4,
                    speed: 12, // Légèrement plus rapide
                    player: ship.player
                });
            });
        }
        // Troisième powerUp - pattern complet avec 3 rangées
        else if (ship.powerUpLevel >= 3) {
            // Première rangée (base)
            [-15, -2.5, 10].forEach(xOffset => {
                ship.bullets.push({
                    x: ship.x + ship.width / 2 + xOffset,
                    y: ship.y,
                    width: 4,
                    height: 4,
                    speed: 10,
                    player: ship.player
                });
            });
            
            // Deuxième rangée (décalée de 4px vers le haut)
            [-20, -10, 5, 15].forEach(xOffset => {
                ship.bullets.push({
                    x: ship.x + ship.width / 2 + xOffset,
                    y: ship.y - 4,
                    width: 4,
                    height: 4,
                    speed: 12,
                    player: ship.player
                });
            });
            
            // Troisième rangée (décalée de 8px vers le haut)
            [-25, -15, 0, 10, 20].forEach(xOffset => {
                ship.bullets.push({
                    x: ship.x + ship.width / 2 + xOffset,
                    y: ship.y - 8,
                    width: 4,
                    height: 4,
                    speed: 14, // Encore plus rapide
                    player: ship.player
                });
            });
        }

        // Limiter le nombre de balles pour éviter les problèmes de performance
        if (ship.bullets.length > 100) {
            ship.bullets = ship.bullets.slice(-100);
        }
    });
}
function shootEnemyBullets() {
    if (gameManager.isPaused) return;

    const maxNewBullets = 10;
    let newBullets = 0;

    for (let i = 0; i < enemies.length && newBullets < maxNewBullets; i++) {
        const enemy = enemies[i];

        if (Math.random() > 0.2) continue;

       // Cas spécial pour enemy8 - tire une boule de chaque côté
if (enemy.type === 7) { // enemy8 (index commence à 0)
    // Boule gauche
    enemyBullets.push({
        x: enemy.x - 15, // À gauche de l'ennemi
        y: enemy.y + enemy.height/2 - 7.5, // Centré verticalement
        width: 15, // Diamètre de 15px
        height: 15, // Pour garder un cercle
        speed: 0,
        vx: -2,
    vy: 0,
    isSpecialEnemyBullet: true, // Nouvelle propriété
    enemyType: 8, // Indiquer quel type d'ennemi a tiré
        color: "cyan", // La couleur de ses propres balles
        isMiniBossBullet: true, // Pour utiliser le rendu spécial
        isRedBall: true, // Pour qu'il soit rendu comme une boule
        type: 0
    });
 
    // Boule droite
    enemyBullets.push({
        x: enemy.x + enemy.width, // À droite de l'ennemi
        y: enemy.y + enemy.height/2 - 7.5, // Centré verticalement
        width: 15, // Diamètre de 15px
        height: 15, // Pour garder un cercle
        speed: 0,
        vx: -2,
    vy: 0,
    isSpecialEnemyBullet: true, // Nouvelle propriété
    enemyType: 8, // Indiquer quel type d'ennemi a tiré
        color: "cyan",
        isMiniBossBullet: true,
        isRedBall: true,
        type: 0
    });
    
    playSound(soundEffects.shoot);
}
        // Cas spécial pour enemy12 - tir horizontal
        else if (enemy.type === 11) { // enemy12 (index commence à 0)
            // Tir vers la gauche
            enemyBullets.push({
                x: enemy.x,
                y: enemy.y + enemy.height / 2,
                width: 15,
                height: 15,
                speed: 0,
                vx: -3 * enemyBulletSpeedMultiplier,
    vy: 0,
    isSpecialEnemyBullet: true, // Nouvelle propriété
    enemyType: 12, // Indiquer quel type d'ennemi a tiré
                type: 2 // Type 2 pour la couleur
            });
            
            // Tir vers la droite
            enemyBullets.push({
                x: enemy.x + enemy.width,
                y: enemy.y + enemy.height / 2,
                width: 15,
                height: 15,
                speed: 0,
                vx: -3 * enemyBulletSpeedMultiplier,
    vy: 0,
    isSpecialEnemyBullet: true, // Nouvelle propriété
    enemyType: 12, // Indiquer quel type d'ennemi a tiré
                type: 2 // Type 2 pour la couleur
            });
        } 
        // Traitement normal pour les autres types d'ennemis
        else if (enemy.type === 1) {
            enemyBullets.push(
                {
                    x: enemy.x,
                    y: enemy.y + enemy.height / 2,
                    width: 4, // Diamètre 4px
                    height: 4, // Pour garder un cercle
                    speed: 0,
                    vx: -3 * enemyBulletSpeedMultiplier,
                    type: 1
                },
                {
                    x: enemy.x + enemy.width,
                    y: enemy.y + enemy.height / 2,
                    width: 4, // Diamètre 4px
                    height: 4, // Pour garder un cercle
                    speed: 0,
                    vx: 3 * enemyBulletSpeedMultiplier,
                    type: 1
                }
            );
        } else {
            // Tir normal vers le bas
            enemyBullets.push({
                x: enemy.x + enemy.width / 2 - 2, // Centré (4px de diamètre)
                y: enemy.y + enemy.height,
                width: 4, // Diamètre 4px
                height: 4, // Pour garder un cercle
                speed: 3 * enemyBulletSpeedMultiplier,
                type: Math.floor(Math.random() * 3)
            });
           
            // Tir vers l'arrière (vers le haut) uniquement en stage 2
            if (isStage2) {
                enemyBullets.push({
                    x: enemy.x + enemy.width / 2 - 2, // Centré (4px de diamètre)
                    y: enemy.y,
                    width: 4, // Diamètre 4px
                    height: 4, // Pour garder un cercle
                    speed: -3 * enemyBulletSpeedMultiplier, // Vitesse négative pour aller vers le haut
                    type: Math.floor(Math.random() * 3)
                });
            }
        }

        newBullets++;
    }

    if (enemyBullets.length > 100) {
        enemyBullets = enemyBullets.slice(-100);
    }
}

        function generateEnemies() {
            if (gameManager.isPaused) return;

            if (enemies.length > 30) {
                return;
            }

            const count = Math.min(7, 30 - enemies.length);

            for (let i = 0; i < count; i++) {
                enemies.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height / 3),
                    width: 60,
                    height: 60,
                    vx: (Math.random() * 2 - 1) * 2,
                    vy: Math.random() * 1.5,
                    type: Math.floor(Math.random() * 6)
                });
            }
        }

        function drawStarship() {
    const drawPlayer = (player, img) => {
        if (!player || !player.isActive) return;

        if (img && img.complete && img.naturalWidth > 0) {
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
           
            // Rotation uniquement pour le joueur 1
            if (player === starship) {
                if (player.x !== lastShipX) {
                    const moveDirection = player.x - lastShipX;
                    if (moveDirection < 0) {
                        shipRotation = Math.max(-maxRotation, shipRotation - rotationSpeed);
                    } else if (moveDirection > 0) {
                        shipRotation = Math.min(maxRotation, shipRotation + rotationSpeed);
                    }
                    lastShipX = player.x;
                } else {
                    if (shipRotation > 0) {
                        shipRotation = Math.max(0, shipRotation - rotationSpeed/2);
                    } else if (shipRotation < 0) {
                        shipRotation = Math.min(0, shipRotation + rotationSpeed/2);
                    }
                }
                ctx.rotate(shipRotation * Math.PI / 180);
            }
           
            ctx.drawImage(
                img,
                -player.width/2,
                -player.height/2,
                player.width,
                player.height
            );
            ctx.restore();
        } else {
            const colors = {
                1: "#04fbac",
                2: "#FF7F50",
                3: "#FFFF50"
            };
            ctx.fillStyle = colors[player.player];
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
    };

    drawPlayer(starship, starshipImg);
    if (isMultiplayer) drawPlayer(starship2, starship2Img);
    if (isTriplePlayer) drawPlayer(starship3, starship3Img);
}

function drawBullets() {
    const drawPlayerBullets = (player) => {
        if (!player || !player.isActive) return;

        player.bullets = player.bullets.filter(bullet => {
            const isOnScreen = bullet.y > -20 && bullet.y < canvas.height + 20 &&
                             bullet.x > -20 && bullet.x < canvas.width + 20;

            if (isOnScreen) {
                // Déterminer la couleur selon le joueur
                let bulletColor;
                if (player.player === 1) bulletColor = "#04fbac"; // Vert-bleu
                else if (player.player === 2) bulletColor = "#FF7F50"; // Orange
                else if (player.player === 3) bulletColor = "#FFFF50"; // Jaune
                else bulletColor = "white";
                
                // Dessiner une boule au lieu d'une image
                ctx.save();
                ctx.fillStyle = bulletColor;
                ctx.shadowColor = bulletColor;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(
                    bullet.x + bullet.width/2, 
                    bullet.y + bullet.width/2, 
                    bullet.width/2, // Rayon = moitié de la largeur
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
                ctx.restore();

                // Mettre à jour la position
                if (bullet.vx !== undefined && bullet.vy !== undefined) {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                } else {
                    bullet.y -= bullet.speed;
                }
            }

            return isOnScreen;
        });
    };

    drawPlayerBullets(starship);
    if (isMultiplayer) drawPlayerBullets(starship2);
    if (isTriplePlayer) drawPlayerBullets(starship3);
}

          
        function drawEnemies() {
            enemies = enemies.filter(enemy => {
                try {
                    ctx.drawImage(enemyImgs[enemy.type], enemy.x, enemy.y, enemy.width, enemy.height);

                    enemy.x += enemy.vx;
                    enemy.y += enemy.vy;

                    if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
                        enemy.vx *= -1;
                    }
                    if (enemy.y <= 0) {
                        enemy.vy *= -1;
                    }

                    return enemy.y < canvas.height;
                } catch (error) {
                    console.error("Erreur lors du dessin d'un ennemi:", error);
                    return false;
                }
            });
        }

        function drawEnemyBullets() {
    enemyBullets = enemyBullets.filter(bullet => {
        try {
            if (bullet.isMiniBossBullet) {
                // Sauvegarde le contexte
                ctx.save();
                
                if (bullet.isRedBall) {
                    // Dessiner une boule avec la taille spécifiée
                    ctx.fillStyle = bullet.color || "red";
                    ctx.shadowColor = bullet.color || "red";
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(
                        bullet.x + bullet.width/2, 
                        bullet.y + bullet.height/2, 
                        bullet.width/2, // Utiliser la taille définie dans le bullet
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                } else {
                    // Dessiner les lasers du mini-boss
                    ctx.fillStyle = bullet.color || "red";
                    ctx.shadowColor = bullet.color || "red";
                    ctx.shadowBlur = 10;
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                }
                
                ctx.restore();
            } else {
                // Pour les balles ennemies normales, respecter la taille définie
                let bulletColor;
                if (bullet.type === 0) bulletColor = "cyan"; 
                else if (bullet.type === 1) bulletColor = "magenta";
                else if (bullet.type === 2) bulletColor = "gold";
                else bulletColor = "white";
                
                // Dessiner une boule colorée avec la taille définie
                ctx.save();
                ctx.fillStyle = bulletColor;
                ctx.shadowColor = bulletColor;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(
                    bullet.x + bullet.width/2, 
                    bullet.y + bullet.height/2, 
                    bullet.width/2, // Utiliser la taille définie dans le bullet
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
                ctx.restore();
            }
            
            // Mettre à jour la position
            if (bullet.vx !== undefined) {
                bullet.x += bullet.vx;
            }
           
            if (bullet.vy !== undefined) {
                bullet.y += bullet.vy;
            } else if (bullet.speed) {
                bullet.y += bullet.speed;
            }

            return bullet.y < canvas.height && bullet.y > 0 && bullet.x > 0 && bullet.x < canvas.width;
        } catch (error) {
            console.error("Erreur lors du dessin d'une balle ennemie:", error);
            return false;
        }
    });
}
        function drawRedPoints() {
    if (redPoints.length > 500) {
        redPoints = redPoints.slice(0, 500);
    }
   
    // Nouvelle approche qui évite les boucles infinies
    redPoints = redPoints.filter((point) => {
        ctx.fillStyle = "red";
        ctx.fillRect(point.x, point.y, 2, 2);
        point.y += 1;
       
        let attractedToPlayer = false;
        let minDistance = Number.MAX_VALUE;
        let attraction = { x: 0, y: 0 };
       
        // Vérifier attraction au joueur 1
        if (starship && starship.isActive) {
            const dx = starship.x + starship.width/2 - point.x;
            const dy = starship.y + starship.height/2 - point.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
           
            if (distance < 100 && distance < minDistance) {
                attraction.x = dx / distance * 3;
                attraction.y = dy / distance * 3;
                minDistance = distance;
                attractedToPlayer = true;
               
                if (distance < 30) {
                    coins += 0.5;
                    document.getElementById("coinsCount").textContent = coins.toFixed(1);
                    playSound(soundEffects.coin);
                    starship.redPointsCollected++;
                   
                    if (starship.redPointsCollected >= 200) {
                        activateShield(starship);
                        starship.redPointsCollected = 0;
                    }
                   
                    return false; // supprime ce point
                }
            }
        }
       
        // Vérifier attraction au joueur 2
        if (isMultiplayer && starship2 && starship2.isActive) {
            const dx = starship2.x + starship2.width/2 - point.x;
            const dy = starship2.y + starship2.height/2 - point.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
           
            if (distance < 100 && distance < minDistance) {
                attraction.x = dx / distance * 3;
                attraction.y = dy / distance * 3;
                minDistance = distance;
                attractedToPlayer = true;
               
                if (distance < 30) {
                    coins += 0.5;
                    document.getElementById("coinsCount").textContent = coins.toFixed(1);
                    playSound(soundEffects.coin);
                    starship2.redPointsCollected++;
                   
                    if (starship2.redPointsCollected >= 200) {
                        activateShield(starship2);
                        starship2.redPointsCollected = 0;
                    }
                   
                    return false; // supprime ce point
                }
            }
        }
       
        // Vérifier attraction au joueur 3
        if (isTriplePlayer && starship3 && starship3.isActive) {
            const dx = starship3.x + starship3.width/2 - point.x;
            const dy = starship3.y + starship3.height/2 - point.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
           
            if (distance < 100 && distance < minDistance) {
                attraction.x = dx / distance * 3;
                attraction.y = dy / distance * 3;
                minDistance = distance;
                attractedToPlayer = true;
               
                if (distance < 30) {
                    coins += 0.5;
                    document.getElementById("coinsCount").textContent = coins.toFixed(1);
                    playSound(soundEffects.coin);
                    starship3.redPointsCollected++;
                   
                    if (starship3.redPointsCollected >= 200) {
                        activateShield(starship3);
                        starship3.redPointsCollected = 0;
                    }
                   
                    return false; // supprime ce point
                }
            }
        }
       
        // Appliquer l'attraction si nécessaire
        if (attractedToPlayer) {
            point.x += attraction.x;
            point.y += attraction.y;
        }
       
        // Conserver le point s'il est toujours dans l'écran
        return point.y <= canvas.height;
    });
}

        function checkCollisions() {
            if (!gameIsRunning || gameManager.isPaused) return;

            if (enemies.length > 40) enemies = enemies.slice(0, 40);
            if (enemyBullets.length > 60) enemyBullets = enemyBullets.slice(0, 60);

            const checkPlayerCollisions = (player, playerNumber) => {
                if (!player || !player.isActive) return;

                // Collisions balles-ennemis
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    let enemyHit = false;

                    for (let j = player.bullets.length - 1; j >= 0; j--) {
                        const bullet = player.bullets[j];
                        if (!bullet || !enemy) continue;

                        if (checkCollision(bullet, enemy)) {
                            playSound(soundEffects.hit);
                            player.bullets.splice(j, 1);
                            enemyHit = true;

                            for (let k = 0; k < 15; k++) {
                                redPoints.push({
                                    x: enemy.x + Math.random() * enemy.width,
                                    y: enemy.y + Math.random() * enemy.height
                                });
                            }

                            handleKill(playerNumber);
                            break;
                        }
                    }

                    if (enemyHit) {
                        enemies.splice(i, 1);
                        continue;
                    }

                    if (checkCollision(player, enemy)) {
                        playSound(soundEffects.hit);
                        if (!player.shield) {
                            player.lives--;
                            updatePlayerStats();
                        }
                        enemies.splice(i, 1);

                        if (player.lives <= 0) {
                            playerDeath(player);
                        }
                    }
                }

                // Collisions avec les balles ennemies
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = enemyBullets[i];
                    if (checkCollision(player, bullet)) {
                        playSound(soundEffects.hit);
                        enemyBullets.splice(i, 1);

                        if (!player.shield) {
                            player.lives--;
                            killsWithoutDeath = 0;
                            updatePlayerStats();
                            if (player.lives <= 0) {
                                playerDeath(player);
                            }
                        }
                    }
                }
            };

            checkPlayerCollisions(starship, 1);
            if (isMultiplayer && starship2) checkPlayerCollisions(starship2, 2);
            if (isTriplePlayer && starship3) checkPlayerCollisions(starship3, 3);

            bonusManager.checkAllCollisions();
            if (isMultiplayer) checkPlayerVsPlayerCollisions();
        }

        function playerDeath(player) {
            player.isActive = false;

            let allPlayersDead = !starship.isActive;
            if (isMultiplayer) allPlayersDead = allPlayersDead && !starship2.isActive;
            if (isTriplePlayer) allPlayersDead = allPlayersDead && !starship3.isActive;

            if (allPlayersDead) {
                gameOver();
            } else {
                const playerMessage = document.createElement("div");
                playerMessage.style.position = "absolute";
                playerMessage.style.color = player.player === 1 ? "#04fbac" :
                                          player.player === 2 ? "#FF7F50" : "#FFFF50";
                playerMessage.style.fontSize = "24px";
                playerMessage.style.fontWeight = "bold";
                playerMessage.style.padding = "10px";
                playerMessage.style.borderRadius = "5px";
                playerMessage.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
                playerMessage.style.left = "50%";
                playerMessage.style.transform = "translateX(-50%)";
                playerMessage.style.zIndex = "100";
                playerMessage.style.top = (30 + (player.player - 1) * 10) + "%";
                playerMessage.textContent = `Joueur ${player.player} T'ES MORT !`;

                document.body.appendChild(playerMessage);

                setTimeout(() => {
                    document.body.removeChild(playerMessage);
                }, 2000);
            }
        }

        function gameOver() {
    document.querySelectorAll("[id^='stun-effect-player'], [id^='shield-effect-player']").forEach(e => e.remove());
    Object.values(soundEffects).forEach(sound => {
        sound.pause();
        sound.currentTime = 0;
    });

    const gameOverContainer = document.getElementById("gameOverContainer");
    const gameOverMessage = document.getElementById("gameOverMessage");
    const continueCounter = document.getElementById("continueCounter");

    gameOverContainer.style.display = "block";
    gameManager.isPaused = true;

    // Jouer le son continue.mp3 pendant le compte à rebours
    playSound(soundEffects.continue);

    let countdown = 5;
    continueCounter.textContent = countdown;

    const countInterval = setInterval(() => {
        countdown--;
        continueCounter.textContent = countdown;

        if (countdown <= 0) {
            clearInterval(countInterval);
            continueCounter.style.display = "none";
            gameOverMessage.style.display = "block";
           
            // Arrêter le son continue et jouer le son gameover
            soundEffects.continue.pause();
            soundEffects.continue.currentTime = 0;
            playSound(soundEffects.gameOver);

            setTimeout(() => {
                gameOverContainer.style.display = "none";
                gameOverMessage.style.display = "none";
                continueCounter.style.display = "block";
                gameManager.isPaused = false;

                // Réinitialisation
                enemies = [];
                enemyBullets = [];
                redPoints = [];
                enemiesKilled = 0;
                simultaneousKills = 0;
                killsWithoutDeath = 0;
                coins = 0;

                [starship, starship2, starship3].filter(Boolean).forEach(player => {
                    player.bullets = [];
                    player.powerUpLevel = 0;
                    player.lives = 3;
                    player.isActive = true;
                });

                if (isMultiplayer) {
                    document.getElementById("p1Points").textContent = "0";
                    document.getElementById("p1Kills").textContent = "0";
                    if (starship2) {
                        document.getElementById("p2Points").textContent = "0";
                        document.getElementById("p2Kills").textContent = "0";
                    }
                    if (isTriplePlayer && starship3) {
                        document.getElementById("p3Points").textContent = "0";
                        document.getElementById("p3Kills").textContent = "0";
                    }
                }

                document.getElementById("livesCount").innerText = playerLives;
                document.getElementById("enemiesKilledCount").innerText = enemiesKilled;
                document.getElementById("coinsCount").textContent = coins.toFixed(1);

                starship.x = canvas.width / 2;
                starship.y = canvas.height - 50;
                if (isMultiplayer && starship2) {
                    starship2.x = canvas.width / 2 + 100;
                    starship2.y = canvas.height - 50;
                }
                if (isTriplePlayer && starship3) {
                    starship3.x = canvas.width / 2 - 100;
                    starship3.y = canvas.height - 50;
                }

                if (enemiesKilled < 5) {
                    playSound(soundEffects.humiliation);
                }
            }, 2000);
        }
    }, 1000);
}

        function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
   
    // Repositionner le vaisseau pour qu'il reste dans les limites du canvas
    if (starship) {
        starship.x = Math.min(starship.x, canvas.width - starship.width);
        starship.y = Math.min(starship.y, canvas.height - starship.height);
    }
    if (starship2) {
        starship2.x = Math.min(starship2.x, canvas.width - starship2.width);
        starship2.y = Math.min(starship2.y, canvas.height - starship2.height);
    }
    if (starship3) {
        starship3.x = Math.min(starship3.x, canvas.width - starship3.width);
        starship3.y = Math.min(starship3.y, canvas.height - starship3.height);
    }
}

function update(timestamp) {
    try {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    
       
        // Ne pas modifier globalAlpha ici pour préserver l'opacité définie dans createBoss

        if (isMultiplayer) {
            updateMultiplayerControls();
        }

        drawStarship();
        // Mise à jour des particules de bouclier
updateShieldParticles();
drawShieldParticles(); // Dessiner les particules du bouclier
        updateStunEffects();
        drawBullets();
        drawEnemies();
        drawEnemyBullets();
        drawRedPoints();

        // Mettre à jour et dessiner le mini-boss
        if (miniBossActive) {
            updateMiniBoss();
            drawMiniBoss();
            checkMiniBossCollisions();
        }

        if (bossActive) {
            updateBoss();
            drawBoss();
            checkBossCollisions();
        }

        bonusManager.update();
        bonusManager.draw(ctx);

        gameManager.draw(ctx);

        checkCollisions();
        if (isMultiplayer) {
            checkPlayerVsPlayerCollisions();
        }
    } catch (error) {
        console.error("Erreur dans la boucle de jeu:", error);
    }

            const currentTime = Date.now();
            const frameDelta = currentTime - (window.lastFrameTime || currentTime);
            window.lastFrameTime = currentTime;

            if (frameDelta > 100) {
                if (frameDelta > 300) {
                    if (enemies.length > 15) enemies = enemies.slice(0, 15);
                    if (enemyBullets.length > 20) enemyBullets = enemyBullets.slice(0, 20);
                    if (redPoints.length > 50) redPoints = redPoints.slice(0, 50);
                }
            }

            requestAnimationFrame(update);
        }

        // Initialisation
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();
// Chargement des ressources
Promise.all([
    ...enemyImgs,
    ...enemyBulletImgs,
    ...powerUpImgs,
    starshipImg,
    bulletImg,
    livesImg,
    bossImg,     // Ajouté
    boss2Img,    // Ajouté
    ...(isMultiplayer ? [starship2Img] : []),
    ...(isTriplePlayer ? [starship3Img] : [])
].filter(Boolean).map(img => new Promise(resolve => {
    if (img.complete) {
        resolve();
    } else {
        img.onload = resolve;
        img.onerror = () => {
            console.error("Erreur de chargement pour:", img.src);
            resolve();
        };
    }
})))
        .then(() => {
            try {
                updatePlayerStats();
                checkGameState();
                requestAnimationFrame(update);

                const intervals = [
                    setInterval(shootBullet, 100),
                    setInterval(generateEnemies, 5000),
                    setInterval(shootEnemyBullets, 1000),
                    setInterval(() => {
                        if (!gameManager.isPaused) {
                            const specialEnemies = enemies.filter(e => e.type === 1).slice(0, 3);
                            specialEnemies.forEach(() => shootEnemyBullets());
                        }
                    }, 500)
                ];

                window.addEventListener("beforeunload", () => {
                    intervals.forEach(clearInterval);
                });

            } catch (error) {
                console.error("Erreur au démarrage du jeu:", error);
            }
        })
        .catch(error => {
            console.error("Erreur lors du chargement des ressources:", error);
        });
    </script>
</body>
</html>